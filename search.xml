<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vi编辑器使用笔记</title>
      <link href="/posts/19289.html"/>
      <url>/posts/19289.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vi编辑器使用笔记"><a href="#Vi编辑器使用笔记" class="headerlink" title="Vi编辑器使用笔记"></a>Vi编辑器使用笔记</h2><h3 id="Vi介绍"><a href="#Vi介绍" class="headerlink" title="Vi介绍"></a>Vi介绍</h3><p>Vi编辑器是Linux系统中最常用，最经典的编辑器，功能非常强大。它不像有图形界面的编辑器，可以进行段落的排版，行间距是多少呀，段落前空几个字符呀这类操作。在Vi编辑器中，只有命令，而且命令很多。</p><h3 id="Vi编辑器的三种模式"><a href="#Vi编辑器的三种模式" class="headerlink" title="Vi编辑器的三种模式"></a>Vi编辑器的三种模式</h3><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>启动Vi后进入的就是命令模式了，在命令模式下，从键盘输入的任何字符都会被当做命令，但字符不会显示出来。比如在命令模式下输入”dd”，此命令会被当做编辑命令来解释，删除光标所在行的所有字符。</p><p>如果命令合法则执行命令，若不合法则触发警告。刚启动Vi底部会显示文件名。</p><p><a href="https://imgchr.com/i/ryZKbT" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/23/ryZKbT.png" alt="刚启动Vi底部显示文件名"></a></p><h4 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h4><p>在命令模式下，从键盘输入”i”，”insert”进入输入模式，这时候，从键盘上输入的字符都会显示在屏幕上。按”Esc”键可以退回到命令模式。</p><p>在输入模式下，底部会显示“插入”的提示字符。</p><p><a href="https://imgchr.com/i/ryeI0K" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/23/ryeI0K.png" alt="Vi编辑器输入模式"></a></p><h4 id="最后行模式"><a href="#最后行模式" class="headerlink" title="最后行模式"></a>最后行模式</h4><p>在命令模式下按下”:”就进入了底线命令模式。经常使用的命令有</p><ul><li>q 退出程序</li><li>w 保存文件</li></ul><p>按”Esc”键可以退回到命令模式</p><p>编辑器底部有”:”的提示是最后行模式。</p><p><a href="https://imgchr.com/i/rymKNF" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/23/rymKNF.png" alt="Vi编辑器最后行模式"></a></p><h3 id="Vi编辑器常用按钮说明"><a href="#Vi编辑器常用按钮说明" class="headerlink" title="Vi编辑器常用按钮说明"></a>Vi编辑器常用按钮说明</h3><h4 id="命令模式下的光标移动"><a href="#命令模式下的光标移动" class="headerlink" title="命令模式下的光标移动"></a>命令模式下的光标移动</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>h或者向左箭头键</td><td>光标向左移动一个字符</td></tr><tr><td>j或者向下箭头键</td><td>光标向下移动一个字符</td></tr><tr><td>k或者向上箭头键</td><td>光标向上移动一个字符</td></tr><tr><td>l或者向右箭头键</td><td>光标向右移动一个字符</td></tr><tr><td>Ctrl+f</td><td>屏幕向下移动一页</td></tr><tr><td>Ctrl+b</td><td>屏幕向上移动一页</td></tr><tr><td>0</td><td>光标移动到这一行的第一个字符</td></tr><tr><td>$</td><td>光标移动到这一行的最后一个字符</td></tr><tr><td>gg</td><td>移动到这个文档的第一行</td></tr></tbody></table><h4 id="命令模式下的删除，复制，黏贴"><a href="#命令模式下的删除，复制，黏贴" class="headerlink" title="命令模式下的删除，复制，黏贴"></a>命令模式下的删除，复制，黏贴</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>x,X</td><td>在一行字当中，x 为向后删除一个字符， X 为向前删除一个字符</td></tr><tr><td>dd</td><td>删除光标所在行</td></tr><tr><td>yy</td><td>复制光标所在行</td></tr><tr><td>p</td><td>p 为将已复制的数据在光标下一行贴上</td></tr><tr><td>u</td><td>复原前一个动作</td></tr><tr><td>Ctrl+r</td><td>重做上一个动作</td></tr></tbody></table><h4 id="最后行模式下命令说明"><a href="#最后行模式下命令说明" class="headerlink" title="最后行模式下命令说明"></a>最后行模式下命令说明</h4><p>“!”符号在Vi编辑器有强制的意思。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>w</td><td>将编辑的数据写入文件</td></tr><tr><td>w！</td><td>若文件的属性是只读的，强制写入文件</td></tr><tr><td>q</td><td>退出Vi</td></tr><tr><td>q!</td><td>文件修改过，不想保存则强制退出</td></tr><tr><td>wq</td><td>保存退出</td></tr></tbody></table><h4 id="最后行模式下显示行号"><a href="#最后行模式下显示行号" class="headerlink" title="最后行模式下显示行号"></a>最后行模式下显示行号</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>set nu</td><td>显示行号</td></tr><tr><td>set nonu</td><td>取消行号</td></tr></tbody></table><p><strong>每天都要精进一点点呀！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vi/Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本编程学习</title>
      <link href="/posts/5226.html"/>
      <url>/posts/5226.html</url>
      
        <content type="html"><![CDATA[<h2 id="shell脚本编程学习"><a href="#shell脚本编程学习" class="headerlink" title="shell脚本编程学习"></a>shell脚本编程学习</h2><h3 id="shell介绍"><a href="#shell介绍" class="headerlink" title="shell介绍"></a>shell介绍</h3><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>介绍不说这么多，主要是学习shell脚本(系统为Linux)。<strong>只要一个写代码的文本编辑器和脚本解释器就可以开始学习shell脚本的快乐之旅啦！</strong></p><h4 id="第一个脚本"><a href="#第一个脚本" class="headerlink" title="第一个脚本"></a>第一个脚本</h4><p>用vi文本编辑器，新建一个hello_world.sh，<strong>.sh</strong>是文件扩展名，代表是shell脚本，看见.sh就晓得是shell编写的脚本了。</p><p><strong>实例</strong></p><pre class=" language-shell"><code class="language-shell">#!/bin/bashecho "Hello world!"</code></pre><p><strong>#!</strong>是约定标记，让系统知道用什么解释器来执行脚本。</p><p><strong>echo</strong>命令是将文本输出到窗口上。</p><p>新建出来的文本是只有读和写权限，并没有执行权限，可以用<strong>chmod</strong>命令赋予新建脚本执行权限，之后再执行。执行后窗口会输出<strong>Hello world!</strong>。</p><p><strong>效果</strong></p><pre><code>/public/bss_sx/test&gt;chmod +x ./hello_world.sh/public/bss_sx/test&gt;./hello_world.shHello world!</code></pre><h3 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h3><p>定义变量时，变量名不用加<strong>$</strong>符号。变量的命名规则在shell里也要遵守，就不多说了。<strong>注意：</strong>赋值号两边不要有空格</p><p><strong>实例</strong></p><pre class=" language-shell"><code class="language-shell">#!/bin/bash#定义变量hello="hello_world!"#使用变量要在变量前面加$符号echo $hello#只读变量，这种变量只能读，不能更改它的值readonly hellohello="你好!"echo $hello</code></pre><p>脚本执行后会有个报错，就是只读变量是不能改变它的值的。</p><p><strong>效果</strong></p><pre><code>/public/bss_sx/test&gt;./hello_world.shhello_world!./hello_world.sh:行8: hello: 只读变量hello_world!</code></pre><h3 id="shell数组"><a href="#shell数组" class="headerlink" title="shell数组"></a>shell数组</h3><p>shell只支持一维数组，不支持多维。数组元素下标由0开始。shell数组用括号表示，元素用<strong>空格符</strong>隔开。</p><p><strong>实例</strong></p><pre class=" language-shell"><code class="language-shell">#!/bin/basharr=("迪迦" "戴拿" "盖亚")#获取数组中的所有元素可以用@ 或 *echo ${arr[@]}#也可以用下标来定义数组arr2[0]=1arr2[1]=2arr2[2]=3#读取数组用大括号echo ${arr2[2]}</code></pre><p><strong>效果</strong></p><pre><code>/public/bss_sx/test&gt;./hello_world.sh迪迦 戴拿 盖亚3</code></pre><h3 id="shell传递参数"><a href="#shell传递参数" class="headerlink" title="shell传递参数"></a>shell传递参数</h3><p>在执行Shell脚本的时候，可以向脚本传递参数。</p><p><strong>实例</strong></p><pre class=" language-shell"><code class="language-shell">#!/bin/bashecho "执行的文件名：$0";echo "第一个参数为：$1";echo "第二个参数为：$2";echo "第三个参数为：$3";# $# 获取参数个数echo "参数个数为：$#";#  $*引用所有参数echo "传递的参数作为一个字符串显示：$*";</code></pre><p><strong>效果</strong></p><pre><code>/public/bss_sx/test&gt;./hello_world.sh 1 2 3执行的文件名：./hello_world.sh第一个参数为：1第二个参数为：2第三个参数为：3参数个数为：3传递的参数作为一个字符串显示：1 2 3</code></pre><h3 id="shell运算符"><a href="#shell运算符" class="headerlink" title="shell运算符"></a>shell运算符</h3><p><strong>算术运算符</strong></p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加法</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>/</td><td>除法</td></tr><tr><td>%</td><td>取余</td></tr><tr><td>=</td><td>赋值</td></tr><tr><td>==</td><td>相等。用于比较两个数字，相同则返回true</td></tr><tr><td>！=</td><td>不相等。用于比较两个数字，不相等则返回false</td></tr></tbody></table><p><strong>关系运算符</strong></p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>检查两个数是否相等，相等返回true</td></tr><tr><td>-ne</td><td>检查两个数是否不相等，不相等返回true</td></tr><tr><td>-gt</td><td>检查左边的数是否大于右边的，如果是，则返回 true</td></tr><tr><td>-lt</td><td>检查左边的数是否小于右边的，如果是，则返回true</td></tr><tr><td>-ge</td><td>检查左边的数是否大于等于右边的，如果是，则返回true</td></tr><tr><td>-le</td><td>检查左边的数是否小于等于右边的，如果是，则返回true</td></tr></tbody></table><p><strong>布尔运算符</strong></p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>！</td><td>非运算</td></tr><tr><td>-o</td><td>或运算</td></tr><tr><td>-a</td><td>与运算</td></tr></tbody></table><p><strong>逻辑运算符</strong></p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑的AND</td></tr><tr><td>||</td><td>逻辑的OR</td></tr></tbody></table><p><strong>实例</strong></p><pre class=" language-shell"><code class="language-shell">#!/bin/bashval=`expr 2 + 3`echo "两数之和等于：$val"</code></pre><p><strong>效果</strong></p><pre><code>/public/bss_sx/lzs&gt;./shell.sh两数之和等于：5</code></pre><h3 id="shell流程控制"><a href="#shell流程控制" class="headerlink" title="shell流程控制"></a>shell流程控制</h3><p>shell的流程控制和C++的类似，都有if-else，for，while，continue，break关键字。写个实例就明白了。</p><p><strong>实例</strong></p><pre class=" language-shell"><code class="language-shell">#!/bin/bashnum1=1num2=2if [ $num1 == $num2 ]then   echo "num1 等于 num2"elif [ $num1 -gt $num2 ]then   echo "num1 大于 num2"elif [ $num1 -lt $num2 ]then   echo "num1 小于 num2"else   echo "没有符合的条件"fi</code></pre><p><strong>效果</strong></p><pre><code>/public/bss_sx/lzs&gt;./shell.shnum1 小于 num2</code></pre><h3 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h3><p>shell的函数定义格式</p><pre><code>[ function ] funname [()]{    action;    [return int;]}</code></pre><p><strong>实例</strong></p><pre class=" language-shell"><code class="language-shell">#!/bin/bashfunAdd(){    echo "输入第一个数字: "    read Num1    echo "输入第二个数字: "    read Num2    echo "两个数字分别为 $Num1 和 $Num2 !"    return $(($Num1+$Num2))}funAddecho "输入的两个数字之和为 $? !"#函数的返回值可以在调用该函数之后获得</code></pre><p><strong>效果</strong></p><pre><code>/public/bss_sx/lzs&gt;./shell.sh输入第一个数字:2输入第二个数字:3两个数字分别为 2 和 3 !输入的两个数字之和为 5 !</code></pre><p><strong>shell学习之旅到此结束！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile学习笔记</title>
      <link href="/posts/62371.html"/>
      <url>/posts/62371.html</url>
      
        <content type="html"><![CDATA[<h2 id="Makefile学习笔记"><a href="#Makefile学习笔记" class="headerlink" title="Makefile学习笔记"></a>Makefile学习笔记</h2><h3 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h3><pre><code>makefile的主要好处是：自动化编译。makefile文件写好后，只需要一个make命令就可以将整个工程完全自动编译，很大程度上提高了软件开发效率。</code></pre><h3 id="Makefile学习–第一层（显示规则）"><a href="#Makefile学习–第一层（显示规则）" class="headerlink" title="Makefile学习–第一层（显示规则）"></a>Makefile学习–第一层（显示规则）</h3><ul><li><p>#号开头是Makefile文件的注释</p></li><li><p>目标文件：依赖文件</p></li><li><p>Tab+操作系统的命令</p></li><li><p>.PHONY:是伪目标</p></li></ul><p>定义好文件的依赖关系之后，下一行以Tab键作为开头，后续接一个操作系统的命令。</p><p>先有一个hello.c文件，需要生成hello可执行文件，makefile代码示例如下:</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">hello.o </span><span class="token punctuation">:</span> hello.c    gcc -c hello.c -o hello.o<span class="token symbol">hello.o </span><span class="token punctuation">:</span> hello.s    gcc -c hello.s -o hello.o<span class="token symbol">hello.s </span><span class="token punctuation">:</span> hello.i    gcc -s hello.i -o hello.s<span class="token symbol">hello.i </span><span class="token punctuation">:</span> hello.c    gcc -e hello.c -o hello.i<span class="token builtin">.PHONY</span><span class="token punctuation">:</span><span class="token symbol">clear</span><span class="token punctuation">:</span>    rm -rf hello.o hello.s hello.i hello</code></pre><p>要生成hello可执行文件，使用make命令执行makefile文件后，1.makefile文件会找到第一个目标文件，然后看看目标文件所需要的依赖文件。</p><p>2.如果依赖文件一需要依赖文件，这时候这个依赖文件就变成了目标文件。类似递归，一层一层的往下走。</p><p>3.往下找完之后，文件存在执行完，生成hello可执行文件。</p><p>4.正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）</p><h3 id="Makefile学习–第二层-变量"><a href="#Makefile学习–第二层-变量" class="headerlink" title="Makefile学习–第二层(变量)"></a>Makefile学习–第二层(变量)</h3><ul><li><p>“=”号操作符：在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。比如：TAR = hello.c</p></li><li><p>“:=”号操作符：表示恒等，常量。例如命令标识符gcc，一般情况下是不会修改的。可写作 CC ：= gcc，之后用CC代替gcc。</p></li><li><p>“+=” 号操作符：如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符。比如：OBJ  = hello.o hello.s</p><pre><code>                OBJ += hello.i hello</code></pre><p>于是，我们的 <code>$(OBJ)</code> 值变成：“hello.o hello.s hello.i hello”（ hello.i hello被追加进去了）</p><ul><li><p>使用  $(变量名)  进行替换。</p><p>代码示例，在上次的代码中改：</p></li></ul><pre class=" language-makefile"><code class="language-makefile">TAR <span class="token operator">=</span> hello.cCC <span class="token operator">:=</span> gccOBJ <span class="token operator">=</span> hello.o hello.sOBJ <span class="token operator">+=</span> hello.i hello<span class="token symbol">hello.o </span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>TAR<span class="token punctuation">)</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>TAR<span class="token punctuation">)</span> -o hello.o<span class="token symbol">hello.o </span><span class="token punctuation">:</span> hello.s    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c hello.s -o hello.o<span class="token symbol">hello.s </span><span class="token punctuation">:</span> hello.i    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -s hello.i -o hello.s<span class="token symbol">hello.i </span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>TAR<span class="token punctuation">)</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -e <span class="token variable">$</span><span class="token punctuation">(</span>TAR<span class="token punctuation">)</span> -o hello.i<span class="token builtin">.PHONY</span><span class="token punctuation">:</span><span class="token symbol">clear</span><span class="token punctuation">:</span>    rm -rf <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span></code></pre></li></ul><h3 id="Makefile学习–第三层-隐含规则"><a href="#Makefile学习–第三层-隐含规则" class="headerlink" title="Makefile学习–第三层(隐含规则)"></a>Makefile学习–第三层(隐含规则)</h3><ul><li>%.c  *.o:表示任意的.c或者.o</li><li>*.c   *.o表示所有的.c或者.o</li></ul><p>现有makefile文件代码如下：</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">hello.o </span><span class="token punctuation">:</span> hello.cgcc -c hello.c -o hello.o<span class="token symbol">h.o </span><span class="token punctuation">:</span> o.cgcc -c o.c -o h.o<span class="token symbol">a.o </span><span class="token punctuation">:</span> b.cgcc -c b.c -o a.o</code></pre><p>用隐含规则的方法，上面代码只需写成两行</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">*.o </span><span class="token punctuation">:</span> *.cgcc -c *.c -o *.o</code></pre><h3 id="Makefile学习–第四层-通配符"><a href="#Makefile学习–第四层-通配符" class="headerlink" title="Makefile学习–第四层(通配符)"></a>Makefile学习–第四层(通配符)</h3><ul><li>$@表示所有的目标文件</li><li>$^表示所有的依赖文件</li><li>$&lt;表示所有依赖文件的第一个文件</li></ul><p>代码示例如下：</p><pre class=" language-makefile"><code class="language-makefile"><span class="token comment" spellcheck="true">#原代码</span>TAR <span class="token operator">=</span> hello.cCC <span class="token operator">:=</span> gccOBJ <span class="token operator">=</span> hello.o hello.sOBJ <span class="token operator">+=</span> hello.i hello<span class="token symbol">hello.o </span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>TAR<span class="token punctuation">)</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>TAR<span class="token punctuation">)</span> -o hello.o<span class="token comment" spellcheck="true">#使用通配符后写的代码</span>TAR <span class="token operator">=</span> hello.cCC <span class="token operator">:=</span> gccOBJ <span class="token operator">=</span> hello.o hello.sOBJ <span class="token operator">+=</span> hello.i hello<span class="token symbol">hello.o </span><span class="token punctuation">:</span> <span class="token variable">$^</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$^</span> -o hello.o</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code> 几乎项目中的每个模块都有一个makefile文件，之前并有没有接触过大型的项目，对makefile了解甚少，需要将这块知识补起来。学习makefile的过程中，将学习到的东西记录下来。嘿嘿</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB学习笔记</title>
      <link href="/posts/14893.html"/>
      <url>/posts/14893.html</url>
      
        <content type="html"><![CDATA[<h2 id="GDB学习笔记"><a href="#GDB学习笔记" class="headerlink" title="GDB学习笔记"></a>GDB学习笔记</h2><h3 id="GDB介绍与功能"><a href="#GDB介绍与功能" class="headerlink" title="GDB介绍与功能"></a>GDB介绍与功能</h3><p><strong>介绍：</strong>  UNIX及UNIX-like下的调试工具。或许，各位比较喜欢那种图形界面方式的，像VC、BCB等IDE的调试，但如果你是在 UNIX平台下做软件，你会发现GDB这个调试工具相比于VC、z的优点是具有修复网络断点以及恢复链接等功能，比BCB的图形化调试器有更强大的功能。所谓“尺有所短，寸有所长”就是这个道理。</p><p><strong>功能：</strong>一般来说，GDB主要帮助你完成下面四个方面的功能：</p><ul><li><p>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</p></li><li><p>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</p></li><li><p>当程序被停住时，可以检查此时你的程序中所发生的事。</p></li><li><p>你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。</p></li></ul><p>GDB的<a href="[http://sourceware.org/gdb/current/onlinedocs/gdb/](https://links.jianshu.com/go?to=http%3A%2F%2Fsourceware.org%2Fgdb%2Fcurrent%2Fonlinedocs%2Fgdb%2F)">官方文档</a></p><h3 id="使用GDB调试"><a href="#使用GDB调试" class="headerlink" title="使用GDB调试"></a>使用GDB调试</h3><p><strong>编译时用-g选项</strong></p><pre><code>$ gcc -g program.c -o programname</code></pre><p><strong>启动程序，programname是执行文件</strong></p><pre><code>gdb programname</code></pre><p><strong>在程序中设置断点</strong></p><p><code>break</code> 设置断点，可以简写为b<br><code>b 10</code>设置断点，在源程序第10行<br><code>b func()</code>设置断点，在<code>func</code>函数入口处</p><pre><code>(gdb) b func()</code></pre><p>设置C++函数断点的时候，需要在函数前面增加增加类名。因为C++具有多态的特性</p><pre><code>(gdb) break Class::func() </code></pre><p>查询所有断点</p><pre><code>(gdb) info b</code></pre><p>跳到下一个断点</p><pre><code>(gdb) c</code></pre><p><strong>启动程序时指定参数</strong></p><pre><code>(gdb) r 202010 919</code></pre><p>重启程序</p><pre><code>(gdb) killKill the program being debugged? (y or n) y(gdb) run</code></pre><p><strong>单步调试</strong></p><p><code>next</code> 单步跟踪，函数调用当作一条简单语句执行，可简写为n</p><p><code>step</code> 单步跟踪，函数调进入被调用函数体内，可简写为s</p><pre><code>(gdb)n(gdb)c</code></pre><p><strong>退出GDB</strong></p><pre><code>(gdb) quitThe program is running. Exit anyway? (y or n) </code></pre><h3 id="在GDB显示变量"><a href="#在GDB显示变量" class="headerlink" title="在GDB显示变量"></a>在GDB显示变量</h3><p><strong>查看变量</strong></p><p><code>print</code>打印变量，可简写为p</p><pre><code>(gdb) p a</code></pre><p><strong>按格式打印变量</strong></p><ul><li><p>x 按十六进制格式显示变量。</p></li><li><p>d 按十进制格式显示变量。</p></li><li><p>u 按十六进制格式显示无符号整型。</p></li><li><p>o 按八进制格式显示变量。</p></li><li><p>t 按二进制格式显示变量。</p></li><li><p>a 按十六进制格式显示变量。</p></li><li><p>c 按字符格式显示变量。</p></li><li><p>f 按浮点数格式显示变量。</p></li></ul><pre><code>(gdb) p/x a</code></pre><p><strong>显示变量类型</strong></p><pre><code>(gdb) whatis p</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯后台笔试题--压缩算法</title>
      <link href="/posts/42441.html"/>
      <url>/posts/42441.html</url>
      
        <content type="html"><![CDATA[<h2 id="腾讯后台笔试题–压缩算法"><a href="#腾讯后台笔试题–压缩算法" class="headerlink" title="腾讯后台笔试题–压缩算法"></a>腾讯后台笔试题–压缩算法</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字符串中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为<a href="m为一个整数且1<=m<=100">m|S</a>，例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符串，你能帮助他进行解压缩么？ </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>利用栈的先进后出的特性</p><p>将】前的先全部进栈，然后将|后的字符串放进临时变量里，按|前的数字有多少依次增加（注意每出完一类型的字符串就翻转一次，同时还要将“】”，“|”出栈。）</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int main(){    string str;    cin&gt;&gt;str;    int length = str.size();    stack&lt;char&gt; str_stack;    for(int i = 0;i &lt; length;i++){        if(str[i] != &#39;]&#39;){            str_stack.push(str[i]);        }else{            string temp = &quot;&quot;;            while(str_stack.top() != &#39;|&#39;){                temp += str_stack.top();                str_stack.pop();            }            reverse(temp.begin(),temp.end());            str_stack.pop();            string num = &quot;&quot;;            while(str_stack.top() != &#39;[&#39;){                num += str_stack.top();                str_stack.pop();            }            str_stack.pop();            reverse(num.begin(),num.end());            int nums = stoi(num);            while(nums--){                for(int i = 0;i &lt; temp.size();i++){                    str_stack.push(temp[i]);                }            }        }    }    string ans;    while(!str_stack.empty()){        ans += str_stack.top();        str_stack.pop();    }    reverse(ans.begin(),ans.end());    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>腾讯一面笔试题</title>
      <link href="/posts/8991.html"/>
      <url>/posts/8991.html</url>
      
        <content type="html"><![CDATA[<h2 id="腾讯一面笔试题"><a href="#腾讯一面笔试题" class="headerlink" title="腾讯一面笔试题"></a>腾讯一面笔试题</h2><h3 id="假期"><a href="#假期" class="headerlink" title="假期"></a>假期</h3><p>由于业绩优秀，公司给小Q放了 n 天的假，身为工作狂的小Q打算在在假期中工作、锻炼或者休息。他有个奇怪的习惯：不会连续两天工作或锻炼。只有当公司营业时，小Q才能去工作，只有当健身房营业时，小Q才能去健身，小Q一天只能干一件事。给出假期中公司，健身房的营业情况，求小Q最少需要休息几天。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目中有状态转换，用动态规划的思想。</p><p>小Q有工作，健身，休息三中状态，用dp【i】【0】，dp【i】【1】，dp【i】【2】分别表示他们的状态。求最多不休息的天数，然后用总天数减去不休息的天数等于休息天数。</p><p>动态方程为：</p><p>dp【i】【0】 = max(dp【i-1】【1】,dp【i-1】【2】) + 1<br>dp【i】【1】 = max(dp【i-1】【0】,dp【i-1】【2】) + 1 </p><p>dp【i】【2】 = max(dp【i-1】【0】,dp【i-1】【1】,dp【i-1】【2】)</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int n;    while(cin&gt;&gt;n){        vector&lt;int&gt; arr1(n,0);        vector&lt;int&gt; arr2(n,0);        for(int i = 0;i &lt; n;i++){            cin&gt;&gt;arr1[i];        }        for(int i = 0;i &lt; n;i++){            cin&gt;&gt;arr2[i];        }        vector&lt;vector&lt;int&gt;&gt; dp(n + 1,vector&lt;int&gt;(3));        dp[0][0] = dp[0][1] = dp[0][2] = 0;        for(int i = 1;i &lt;= n;i++){            if(arr1[i - 1] == 1){                dp[i][0] = max(dp[i - 1][1],dp[i - 1][2]) + 1;            }            if(arr2[i - 1] == 1){                dp[i][1] = max(dp[i - 1][0],dp[i - 1][2]) + 1;            }            dp[i][2] = max(dp[i - 1][0],max(dp[i - 1][1],dp[i - 1][2]));        }        cout&lt;&lt;n - max(dp[n][0],max(dp[n][2],dp[n][1]))&lt;&lt;endl;;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 腾讯 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>select，poll，epoll的介绍</title>
      <link href="/posts/13106.html"/>
      <url>/posts/13106.html</url>
      
        <content type="html"><![CDATA[<h2 id="select，poll-epoll的介绍"><a href="#select，poll-epoll的介绍" class="headerlink" title="select，poll,  epoll的介绍"></a>select，poll,  epoll的介绍</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select：是最初解决IO阻塞问题的方法。用结构体fd_set来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。</p><p>存在的问题：</p><ul><li><p>内置数组的形式使得select的最大文件数受限与FD_SIZE；</p></li><li><p>每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态；</p></li><li><p>轮寻排查当文件描述符个数很多时，效率很低；</p></li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll：通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。</p><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式</p><ul><li>LT模式</li></ul><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p><ul><li>ET模式</li></ul><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程、进程间的通信</title>
      <link href="/posts/37183.html"/>
      <url>/posts/37183.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程与线程、进程间的通信"><a href="#进程与线程、进程间的通信" class="headerlink" title="进程与线程、进程间的通信"></a>进程与线程、进程间的通信</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p><p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><ul><li><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p></li><li><p>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p></li><li><p>进程是资源分配的最小单位，线程是CPU调度的最小单位；</p></li><li><p>系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p></li><li><p>通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预</p></li><li><p>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p></li><li><p>进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉</p></li><li><p>进程适应于多核、多机分布；线程适用于多核</p></li></ul><h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p><p>1.1 普通管道PIPE：</p><p>1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p><p>2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p><p>3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p><p>1.2 命名管道FIFO：</p><p>1)FIFO可以在无关的进程之间交换数据</p><p>2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p><h4 id="系统IPC"><a href="#系统IPC" class="headerlink" title="系统IPC"></a>系统IPC</h4><p>2.1 消息队列</p><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p><p>特点：</p><p>1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p><p>2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p><p>3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p><p>2.2 信号量semaphore</p><p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><p>特点：</p><p>1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p><p>2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p><p>3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p><p>4)支持信号量组。</p><p>2.3 信号signal</p><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>2.4 共享内存（Shared Memory）</p><p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</p><p>特点：</p><p>1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p><p>2)因为多个进程可以同时操作，所以需要进行同步</p><p>3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</p><h4 id="套接字socket"><a href="#套接字socket" class="headerlink" title="套接字socket"></a>套接字socket</h4><p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p><p>线程间通信的方式:</p><p>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p><p>互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p><p>信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p><p>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数组中重复的数字</title>
      <link href="/posts/38278.html"/>
      <url>/posts/38278.html</url>
      
        <content type="html"><![CDATA[<h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>由于所有元素值是有范围的，因此可以用一个长度为n的数组，下标表示序列中的每一个值，下标对应的值表示该下标出现的次数。  </p></li><li><p>只需扫描一次原序列，就统计出所有元素出现的次数；  </p></li><li><p>再扫描一次哈希数组，找到一个出现次数大于1的值即可。</p></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>class Solution {public:    // Parameters:    //        numbers:     an array of integers    //        length:      the length of array numbers    //        duplication: (Output) the duplicated number in the array number    // Return value:       true if the input is valid, and there are some duplications in the array number    //                     otherwise false    bool duplicate(int numbers[], int length, int* duplication) {        if(length == 0)            return false;        for(int i = 0;i &lt; length;i++){            if(numbers[i] &lt; 0 || numbers[i] &gt; length - 1){                return false;            }        }        vector&lt;int&gt; arr(length,0);        for(int i = 0;i &lt; length;i++){            arr[numbers[i]]++;        }        for(int i = 0;i &lt; arr.size();i++){            if(arr[i] &gt; 1){                *duplication = i;                return true;            }        }        return false;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序算法</title>
      <link href="/posts/60244.html"/>
      <url>/posts/60244.html</url>
      
        <content type="html"><![CDATA[<h2 id="八大排序算法"><a href="#八大排序算法" class="headerlink" title="八大排序算法"></a>八大排序算法</h2><p>排序就是将一组数据按递增或递减的次序排列起来。</p><p>排序可以分为5类</p><ul><li>插入排序</li><li>交换排序</li><li>选择排序</li><li>归并排序</li><li>非比较排序</li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>首先在当前有序区R[1..i-1]中查找R[i]的正确插入位置k(1≤k≤i-1)；然后将R[k．．i-1]中的记录均后移一个位置，腾出k位置上的空间插入R[i]。</p><p>注意：若R[i]的关键字大于等于R[1．．i-1]中所有记录的关键字，则R[i]就是插入原位置。</p><p><strong>实现代码</strong></p><pre><code>void insert_sort(int a[],int length){        int i,j,temp;        for(int i = 0;i &lt; length;i++){            temp = a[i];            for(int j = i - 1;j &gt;= 0 &amp;&amp; temp &lt; a[j];j--){                a[j + 1] = a[j];            }            a[j + 1] = temp;        }    }</code></pre><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序属于插入类排序,是将整个有序序列分割成若干小的子序列分别进行插入排序</p><p>排序过程：先取一个正整数d1&lt;n，把所有序号相隔d1的数组元素放一组，组内进行直接插入排序]；然后取d2&lt;d1，重复上述分组和排序操作；直至di=1，即所有记录放进一个组中排序为止。</p><p><strong>实现代码</strong></p><pre><code>void shell_sort(int a[],int length){        int i,j,h,temp;        for(int h = length / 2;h &gt; 0;h = h / 2){            for(i = h;i &lt; length;i++){                temp = a[i];                for(j = j - h;j &gt;= 0 &amp;&amp; temp &lt; a[j];j = j - h){                    a[j + h] = a[j];                }                a[j + h] = temp;            }        }    }</code></pre><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。  </p></li><li><p>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 [1] </p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。 [1] </p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li></ul><p><strong>实现代码</strong></p><pre><code>void bubble_sort(int a[],int length){        int i,j;        for(i = 0;i &lt; length - 1;i++){            for(j = 0;j &lt; length - 1 - i;j++){                if(a[j] &gt; a[j + 1]){                    int temp = a[j];                    a[j] = a[j + 1];                    a[j + 1] = temp;                }            }        }    }</code></pre><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul><li><p>首先设定一个分界值，通过该分界值将数组分成左右两部分。  </p></li><li><p>将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。</p></li><li><p>然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。  </p></li><li><p>重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。</p></li></ul><p><strong>实现代码</strong></p><pre><code>void quick_sort(int a[],int L,int R){        if(L &gt; R){            return;        }        int left = L;        int right = R;        int key = a[left];        while(left &lt; right){            while(left &lt; right &amp;&amp; a[right] &gt;= key ){                right--;            }            if(left &lt; right){                a[left] = a[right];            }            while(left &lt; right &amp;&amp; a[left] &lt;= key){                left++;            }            if(left &lt; right){                a[right] = a[left];            }            if(left &gt;= right){                a[left] = key;            }        }        quick_sort(a, L,right - 1);        quick_sort(a, right + 1,R);    }</code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p><strong>实现代码</strong></p><pre><code>void select_sort(int a[],int length){        int i,j,temp;        for(i = 0;i &lt; length - 1;i++){            int min = i;            for(j = i + 1;j &lt; length;j++){                if(a[j] &lt; a[min]){                    min = j;                }            }            temp = a[i];            a[i] = a[min];            a[min] = temp;        }    }</code></pre><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：</p><ul><li>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><p><strong>实现代码</strong></p><pre><code>//来源于百度百科void max_heapify(int arr[], int start, int end) {    //建立父节点指标和子节点指标    int dad = start;    int son = dad * 2 + 1;    while (son &lt;= end)  //若子节点指标在范围内才做比较    {            if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) //先比较两个子节点大小，选择最大的            son++;        if (arr[dad] &gt; arr[son]) //如果父节点大於子节点代表调整完毕，直接跳出函数            return;        else  //否则交换父子内容再继续子节点和孙节点比较        {            swap(arr[dad], arr[son]);            dad = son;            son = dad * 2 + 1;        }    }}void heap_sort(int arr[], int len) {    //初始化，i从最後一个父节点开始调整    for (int i = len / 2 - 1; i &gt;= 0; i--)        max_heapify(arr, i, len - 1);    //先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕    for (int i = len - 1; i &gt; 0; i--)     {        swap(arr[0], arr[i]);        max_heapify(arr, 0, i - 1);    }}</code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p></li></ul><p>重复步骤3直到某一指针超出序列尾</p><p>将另一序列剩下的所有元素直接复制到合并序列尾</p><p><strong>实现代码</strong></p><pre><code>//自顶向下的方法//代码源于百度void merge(int *data, int start, int mid, int end, int *result){    int i, j, k;    i = start;    j = mid + 1;                        //避免重复比较data[mid]    k = 0;    while (i &lt;= mid &amp;&amp; j &lt;= end)        //数组data[start,mid]与数组(mid,end]均没有全部归入数组result中去    {        if (data[i] &lt;= data[j])         //如果data[i]小于等于data[j]            result[k++] = data[i++];    //则将data[i]的值赋给result[k]，之后i,k各加一，表示后移一位        else            result[k++] = data[j++];    //否则，将data[j]的值赋给result[k]，j,k各加一    }    while (i &lt;= mid)                    //表示数组data(mid,end]已经全部归入result数组中去了，而数组data[start,mid]还有剩余        result[k++] = data[i++];        //将数组data[start,mid]剩下的值，逐一归入数组result    while (j &lt;= end)                    //表示数组data[start,mid]已经全部归入到result数组中去了，而数组(mid,high]还有剩余        result[k++] = data[j++];        //将数组a[mid,high]剩下的值，逐一归入数组result    for (i = 0; i &lt; k; i++)             //将归并后的数组的值逐一赋给数组data[start,end]        data[start + i] = result[i];    //注意，应从data[start+i]开始赋值}void merge_sort(int *data, int start, int end, int *result){    if (start &lt; end)    {        int mid = start + (end-start) / 2;//避免溢出int        merge_sort(data, start, mid, result);                    //对左边进行排序        merge_sort(data, mid + 1, end, result);                  //对右边进行排序        merge(data, start, mid, end, result);                    //把排序好的数据合并    }}</code></pre><h3 id="非比较性排序"><a href="#非比较性排序" class="headerlink" title="非比较性排序"></a>非比较性排序</h3><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li><p>按照个位数进行排序。</p></li><li><p>按照十位数进行排序。</p></li><li><p>按照百位数进行排序。</p><p>排序后，数列就变成了一个有序序列。</p><p><strong>实现代码</strong></p></li></ul><pre><code>//辅助函数，计算数组中的最大位数    int maxbit(int a[],int length){        int max = 1;        int p = 10;        for(int i = 0;i &lt; length;i++){            while(a[i] &gt;= p){                max++;                p *= 10;            }        }        return max;    }    //基数排序    void radixsort(int a[],int length){        int max = maxbit(a,length); //最大循环次数        int *tmp = new int[length];        int *count = new int[10]; //计数器        int i,j,k;        int radix = 1;        for(i = 0;i &lt; max;i++){            //每次循环将计数器重置            for(j = 0;j &lt; 10;j++){                count[j] = 0;            }            //统计桶里数的个数            for(j = 0;j &lt; length;j++){                k = (a[j] / radix) % 10;                count[k]++;            }            //将tmp的下标位置分配给桶            for(j = 1;j &lt; 10;j++){                count[j] = count[j - 1] + count[j];            }            //将桶的记录的数据依次放进tmp中            for(j = length - 1;j &gt; 0;j--){                k = (a[j] / radix) % 10;                tmp[count[k] - 1] = a[j];                count[k]--;            }            //将tem数组的数据放回到a数组中            for(j = 0;j &lt; length;j++){                a[j] = tmp[j];            }            radix *= 10; //数据的下一位        }        delete []tmp;        delete []count;    }</code></pre><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p><img src="https://cdn.jsdelivr.net/gh/1224756742/imgs2/images/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="算法复杂度"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不用加减乘除做加法</title>
      <link href="/posts/19476.html"/>
      <url>/posts/19476.html</url>
      
        <content type="html"><![CDATA[<h2 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>两个数异或：相当于每一位相加，而不考虑进位；</p></li><li><p>两个数相与，并左移一位：相当于求得进位；</p></li><li><p>将上述两步的结果相加,直到进位结果为0</p></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>class Solution {public:    int Add(int num1, int num2)    {        int sum,carry;        do{            sum = num1^num2;            carry = (num1 &amp; num2)&lt;&lt;1;            num1 = sum;            num2 = carry;         }while(carry != 0);        return sum;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>翻转单词顺序列</title>
      <link href="/posts/20581.html"/>
      <url>/posts/20581.html</url>
      
        <content type="html"><![CDATA[<h2 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从头开始遍历字符串，以空格为分界点，单词为单位逐个添加进新字符串中。</p><p><strong>注意:</strong>最后一个单词后面是没有空格符的，要单独处理。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>class Solution {public:    string ReverseSentence(string str) {        string res=&quot;&quot;;        string temp=&quot;&quot;;        for(int i=0;i&lt;str.size();i++)        {            if(str[i]!=&#39; &#39;)            {                temp+=str[i];            }            else            {                res=&quot; &quot;+temp+res;                temp=&quot;&quot;;            }        }        if(temp.size())            res=temp+res;        return res;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左旋转字符串</title>
      <link href="/posts/11018.html"/>
      <url>/posts/11018.html</url>
      
        <content type="html"><![CDATA[<h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>字符串拼接，n之后的先接起来，然后再把0到n前的接起来即可。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>class Solution {public:    string LeftRotateString(string str, int n) {        string tempstr;        for(int i = n;i &lt; str.size();i++){            tempstr += str[i];        }        for(int i = 0;i &lt; n;i++){            tempstr += str[i];        }        return tempstr;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和为S的两个数字</title>
      <link href="/posts/42360.html"/>
      <url>/posts/42360.html</url>
      
        <content type="html"><![CDATA[<h2 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>对应每个测试案例，输出两个数，小的先输出。</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个数列是一个递增序列，设置两个一头一尾的指针</p><ul><li><p>若array[i] + array[j] == sum，就是答案（相差越远乘积越小） </p></li><li><p>若array[i] + array[j] &gt; sum，array[j]肯定不是答案之一（前面已得出 i 前面的数已是不可能），j – </p></li><li><p>若array[i] + array[j] &lt; sum，arrayi肯定不是答案之一（前面已得出 j 后面的数已是不可能），i ++</p></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>class Solution {public:    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) {        vector&lt;int&gt; result;        int i = 0,j = array.size() - 1;        while(i &lt; j){            if(array[i] + array[j] == sum){                result.push_back(array[i]);                result.push_back(array[j]);                break;            }else if(array[i] + array[j] &gt; sum){                j--;            }else{                i++;            }        }        return result;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>和为S的连续正数序列</title>
      <link href="/posts/11352.html"/>
      <url>/posts/11352.html</url>
      
        <content type="html"><![CDATA[<h2 id="和为S的连续正数序列"><a href="#和为S的连续正数序列" class="headerlink" title="和为S的连续正数序列"></a>和为S的连续正数序列</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>采用双指针的方法，两个指针之间就像一个窗口，通过改变窗口的大小寻找符合题目的答案。</p><ul><li>当总和小于sum，大指针继续增</li><li>否则小指针增</li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) {        vector&lt;vector&lt;int&gt;&gt; result;        int star = 2,end = 1;        while(star &gt; end){            int cur = (star + end)*(star - end + 1) / 2;            if(cur &gt; sum){                end++;            }            if(cur == sum){                vector&lt;int&gt; list;                for(int i = end;i &lt;= star;i++){                    list.push_back(i);                }                result.push_back(list);                end++;            }            if(cur &lt; sum){                star++;            }        }        return result;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础</title>
      <link href="/posts/41347.html"/>
      <url>/posts/41347.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><p>来源于<a href="https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab" target="_blank" rel="noopener">牛客</a></p><h3 id="请你聊一聊数据库事物的一致性"><a href="#请你聊一聊数据库事物的一致性" class="headerlink" title="请你聊一聊数据库事物的一致性"></a>请你聊一聊数据库事物的一致性</h3><h4 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h4><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。</p><p>事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。</p><p>1）原子性（Atomicity）</p><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p>2）一致性（Consistency）</p><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p><p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><p>3）隔离性（Isolation）</p><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p><p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p><p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p><p>不同的隔离级别：</p><p>Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。</p><p>Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。</p><p>Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。</p><p>Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。</p><p>Mysql主要包含四种隔离状态：</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>4）持久性（Durability）</p><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p><h3 id="请你说说索引是什么，多加索引一定会好吗"><a href="#请你说说索引是什么，多加索引一定会好吗" class="headerlink" title="请你说说索引是什么，多加索引一定会好吗"></a>请你说说索引是什么，多加索引一定会好吗</h3><h4 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h4><p>1、索引</p><p>数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。</p><p>DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p><p>优点：</p><p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p>缺点：</p><p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p><p>2、添加索引原则</p><p>在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p>定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p><p>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p><h3 id="请你说一说数据库的三大范式"><a href="#请你说一说数据库的三大范式" class="headerlink" title="请你说一说数据库的三大范式"></a>请你说一说数据库的三大范式</h3><h4 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h4><p>第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分</p><p>第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式</p><p>第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP的三次握手和四次挥手</title>
      <link href="/posts/41882.html"/>
      <url>/posts/41882.html</url>
      
        <content type="html"><![CDATA[<h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h2><p>在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.</p><p>其中，对于我们日常的分析有用的就是前面的五个字段。</p><p>它们的含义是：</p><p>SYN表示建立连接，</p><p>FIN表示关闭连接，</p><p>ACK表示响应，</p><p>PSH表示有 DATA数据传输，</p><p>RST表示连接重置</p><h3 id="TCP保证可靠性："><a href="#TCP保证可靠性：" class="headerlink" title="TCP保证可靠性："></a>TCP保证可靠性：</h3><p>（1）序列号、确认应答、超时重传</p><p>数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</p><p>（2）窗口控制与高速重发控制/快速重传（重复确认应答）</p><p>TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。</p><p>使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒……</p><p>（3）拥塞控制</p><p>如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。</p><p>慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</p><p>拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。</p><p>将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。</p><p>快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。</p><p>然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。</p><p>这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。</p><p>TCP建立连接和断开连接的过程：</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552471554293_3A87D0457A6EE404083BBF3CB192C358" alt="img"></p><h3 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h3><p>\1. Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p><p>\2. Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p><p>\3. Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p><h3 id="为什么不是二次握手和四次握手呢"><a href="#为什么不是二次握手和四次握手呢" class="headerlink" title="为什么不是二次握手和四次握手呢"></a>为什么不是二次握手和四次握手呢</h3><p><strong>二次握手：</strong>客户端请求建立连接，服务端确认连接请求。这个时候客户端知道服务端有发送和接受的能力。<strong>但是</strong>，没有第三次握手，服务端只知道客户端有发送的能力，并不知道其有接受的能力。</p><p><strong>四次握手：</strong>第四握手的作用并没有必要，因为第二次握手已经做了。</p><h3 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h3><p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p><p>1.数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。</p><p>2.服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。</p><p>3.当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认</p><p>4.客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个链表的第一个公共结点</title>
      <link href="/posts/37293.html"/>
      <url>/posts/37293.html</url>
      
        <content type="html"><![CDATA[<h2 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>先计算两个链表的的长度</li><li>让长的链表先走两者长度的差</li><li>开始齐头并进，直到找到第一个公共结点</li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>/*struct ListNode {    int val;    struct ListNode *next;    ListNode(int x) :            val(x), next(NULL) {    }};*/class Solution {public:    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {        ListNode* node1 = pHead1;        ListNode* node2 = pHead2;        int leng1 = length(node1);        int leng2 = length(node2);        int lengcha = 0;        if(leng1 &gt; leng2){            lengcha = leng1 - leng2;            for(int i = 0;i &lt; lengcha;i++){                node1 = node1 -&gt; next;            }        }else{            lengcha = leng2 - leng1;            for(int i = 0;i &lt; lengcha;i++){                node1 = node1 -&gt; next;            }        }        while(node1 != node2){            node1 = node1 -&gt; next;            node2 = node2 -&gt; next;        }        return node1;    }    int length(ListNode* head){            int leng = 0;            ListNode* node = head;            while(node != nullptr){                leng++;                node = node -&gt; next;            }            return leng;        }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个只出现一次的字符</title>
      <link href="/posts/34594.html"/>
      <url>/posts/34594.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先在hash表中统计各字母出现次数，第二次扫描直接访问hash表获得次数。，第二个循环是依据原字符串的顺序进行遍历并在arr中进行查找的，遇到第一个数值对应为1的字符后就直接输出了。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>class Solution {public:    int FirstNotRepeatingChar(string str) {        if(str.size() &lt;= 0)            return -1;        int arr[256] = {0};        for(int i = 0;i &lt; str.size();i++){            arr[str[i]]++;        }        for(int i = 0;i &lt; str.size();i++){            if(arr[str[i]] == 1){                return i;            }        }        return -1;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丑数</title>
      <link href="/posts/4116.html"/>
      <url>/posts/4116.html</url>
      
        <content type="html"><![CDATA[<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>根据丑数的定义，如果一个数能被2整除，3整除，5整除，最后的到1的就是丑数了</p><pre><code>int GetUglyNumber_Solution(int index) {       if(index&lt;=0)        return 0;    int count=0;    bool flag_ugly=false;    int i;    for(i=1;count!=index;i++)        {           if(IfUgly(i))               count++;        }    return i-1;    }    bool IfUgly(int i)     {         int temp=i;         while(temp%2==0)             temp=temp/2;         while(temp%3==0)             temp=temp/3;         while(temp%5==0)             temp=temp/5;         if(temp==1)             return true;         else             return false;     }</code></pre><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>转<a href="https://www.nowcoder.com/questionTerminal/6aa9e04fc3794f68acf8778237ba065b?f=discussion" target="_blank" rel="noopener">事无巨细，悉究本末</a>的描述与代码：</p><p><strong>通俗易懂的解释：</strong>  </p><p>   <strong>首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x * 3 ^ y * 5 ^ z，换句话说一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方\</strong>*得到重复的丑数，而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：**  </p><p>   <strong>（1）丑数数组： 1</strong>  </p><p>   <strong>乘以2的队列：2</strong>  </p><p>   <strong>乘以3的队列：3</strong>  </p><p>   <strong>乘以5的队列：5</strong>  </p><p>   <strong>选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以**</strong>2,3,5<strong>**放入三个队列；</strong>  </p><p>   <strong>（2）丑数数组：1,2</strong>  </p><p>​    <strong>乘以2的队列：4</strong>   </p><p>​    <strong>乘以3的队列：3，6</strong>   </p><p>​    <strong>乘以5的队列：5，10</strong>   </p><p>​    <strong>选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以**</strong>2,3,5<strong>**放入三个队列；</strong>   </p><p>​    <strong>（3）丑数数组：1,2,3</strong>   </p><p>​    <strong>乘以2的队列：4,6</strong>   </p><p>​    <strong>乘以3的队列：6,9</strong>   </p><p>​    <strong>乘以5的队列：5,10,15</strong>   </p><p>​    <strong>选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以**</strong>2,3,5<strong>**放入三个队列；</strong>   </p><p>​    <strong>（4）丑数数组：1,2,3,4</strong>   </p><p>​    <strong>乘以2的队列：6，8</strong>   </p><p>​    <strong>乘以3的队列：6,9,12</strong>   </p><p>​    <strong>乘以5的队列：5,10,15,20</strong>   </p><p>​    <strong>选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以**</strong>2,3,5<strong>**放入三个队列；</strong>   </p><p>​    <strong>（5）丑数数组：1,2,3,4,5</strong>   </p><p>​    <strong>乘以2的队列：6,8,10，</strong>   </p><p>​    <strong>乘以3的队列：6,9,12,15</strong>   </p><p>​    <strong>乘以5的队列：10,15,20,25</strong>   </p><p>​    <strong>选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列；</strong>   </p><p>​    <strong>……………………</strong>   </p><p>​    <strong>疑问：</strong>   </p><p>​    <strong>1.为什么分三个队列？</strong>   </p><p>​    <strong>丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的；</strong>   </p><p>​    <strong>2.为什么比较三个队列头部最小的数放入丑数数组？</strong>   </p><p>​    <strong>因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。</strong>   </p><p>​    <strong>实现思路：</strong>   </p><p>​    <strong>我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组；</strong>   </p><p>​    <strong>（1）1</strong>   </p><p>​    <strong>|2</strong>   </p><p>​    <strong>|3</strong>   </p><p>​    <strong>|5</strong>   </p><p>​    <strong>目前指针指向0,0,0，队列头arr[0] * 2 = 2, arr[0] * 3 = 3, arr[0] * 5 = 5</strong>   </p><p>​    <strong>（2）1 2</strong>   </p><p>​    <strong>2 |4</strong>   </p><p>​    <strong>|3 6</strong>   </p><p>​    <strong>|5 10</strong>   </p><p>​    <strong>目前指针指向1,0,0，队列头arr[1] * 2 = 4, arr[0] * 3 = 3, arr[0] * 5 = 5</strong>   </p><p>​    <strong>（3）1 2 3</strong>   </p><p>​    <strong>2| 4 6</strong>   </p><p>​    <strong>3 |6 9</strong>    </p><p>​    <strong>|5 10 15</strong>   </p><p>   <strong>目前指针指向1,1,0，队列头arr[1] * 2 = 4, arr[1] * 3 = 6, arr[0] * 5 = 5</strong>  </p><p>   <strong>………………</strong></p><pre><code>class Solution {public:    int GetUglyNumber_Solution(int index) {        // 0-6的丑数分别为0-6        if(index &lt; 7) return index;        //p2，p3，p5分别为三个队列的指针，newNum为从队列头选出来的最小数        int p2 = 0, p3 = 0, p5 = 0, newNum = 1;        vector&lt;int&gt; arr;        arr.push_back(newNum);        while(arr.size() &lt; index) {            //选出三个队列头最小的数            newNum = min(arr[p2] * 2, min(arr[p3] * 3, arr[p5] * 5));            //这三个if有可能进入一个或者多个，进入多个是三个队列头最小的数有多个的情况            if(arr[p2] * 2 == newNum) p2++;            if(arr[p3] * 3 == newNum) p3++;            if(arr[p5] * 5 == newNum) p5++;            arr.push_back(newNum);        }        return newNum;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>连续子数组的最大和</title>
      <link href="/posts/22537.html"/>
      <url>/posts/22537.html</url>
      
        <content type="html"><![CDATA[<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用temp记录累计值，max记录和最大<br>基于思想：对于一个数A，若是A的左边累计数非负，那么加上A能使得值不小于A，认为累计值对整体和是有贡献的。如果前几项累计值负数，则认为有害于总和，temp记录当前值。<br>此时 若和大于max 则用max记录下来</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>class Solution {public:    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) {        if(array.size() &lt;= 0)            return 0;        int temp = 0;        int max = array[0];        for(int i = 0;i &lt; array.size();i++){            if(temp &lt;= 0)                temp = array[i];            else{                temp += array[i];            }            if(temp &gt; max){                max = temp;            }        }        return max;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串的排列</title>
      <link href="/posts/3080.html"/>
      <url>/posts/3080.html</url>
      
        <content type="html"><![CDATA[<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>把字符串分为两部分：第一部分为第一个字符，第二部分为第一个字符以后的字符串。</li><li>然后接下来求后面那部分的全排列。</li><li>再将第一个字符与后面的那部分字符逐个交换</li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>class Solution {<br>public:<br>    vector<string> arr;<br>    vector<string> Permutation(string str) {<br>        if(str.size() == 0){<br>            return arr;<br>        }<br>        permutat(str,0);<br>        sort(arr.begin(),arr.end());<br>        auto it = unique(arr.begin(),arr.end());<br>        arr.erase(it,arr.end());<br>        return arr;<br>    }<br>    void permutat(string str,int stat){<br>        int length = str.size();<br>        if(stat == length){<br>            arr.push_back(str);<br>        }<br>        for(int i = stat;i &lt; str.size();i++){<br>            char temp = str[i];<br>            str[i] = str[stat];<br>            str[stat] = temp;<br>            permutat(str,stat + 1);<br>            temp = str[i];<br>            str[i] = str[stat];<br>            str[stat] = temp;<br>        }<br>    }<br>};</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树中和为某一值的路径</title>
      <link href="/posts/36527.html"/>
      <url>/posts/36527.html</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>从根节点开始遍历，直至叶子节点，判断是否为目标路径。</li><li>如果左子树非空，递归左子树</li><li>如果右子树非空，递归右子树</li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>/*struct TreeNode {    int val;    struct TreeNode *left;    struct TreeNode *right;    TreeNode(int x) :            val(x), left(NULL), right(NULL) {    }};*/class Solution {public:    vector&lt;vector&lt;int&gt;&gt; arr;    vector&lt;int&gt; path;    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) {        find(root,expectNumber);        return arr;    }    void find(TreeNode* root,int number){        if(root == nullptr)            return ;        path.push_back(root -&gt; val);        if(!root -&gt; left &amp;&amp; !root -&gt; right &amp;&amp; number == root -&gt; val){            arr.push_back(path);        }else{            if(root -&gt; left){                FindPath(root -&gt; left,number - root -&gt; val);            }            if(root -&gt; right){                FindPath(root -&gt; right,number - root -&gt; val);            }        }        path.pop_back();    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的后序遍历序列</title>
      <link href="/posts/16324.html"/>
      <url>/posts/16324.html</url>
      
        <content type="html"><![CDATA[<h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>后序遍历的序列中，最后一个数字是树的根节点 ，数组中前面的数字可以分为两部分：第一部分是左子树节点的值，都比根节点的值小；第二部分 是右子树节点的值，都比根节点 的值大，后面用递归分别判断前后两部分是否符合以上原则</p><ul><li>确定根节点；</li><li>遍历序列（除去根结点），找到第一个大于根节点的位置，则该位置左边为左子树，右边为右子树；</li><li>遍历右子树，若发现有小于根节点的值，则直接返回false；</li><li>分别判断左子树和右子树是否仍是二叉搜索树</li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>class Solution {public:    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) {        vector&lt;int&gt; lefttree,righttree;        int length = sequence.size();        if(length == 0)            return false;        int root = sequence[length - 1];        int i = 0;        //在二叉搜索 树中 左子树节点小于根节点        for(;i &lt; length - 1;++i){            if(sequence[i] &gt; root)                break;        }        //二叉搜索树中右子树的节点都大于根节点        int j = i;        for(;j &lt; length - 1;++j){            if(sequence[j] &lt; root)                return false;        }        if(i != 0){            for(int k = 0;k &lt; i;++k){                lefttree.push_back(sequence[k]);            }        }        if(j != 0){            for(int k = i;k &lt; length - 1;++k){                righttree.push_back(sequence[k]);            }        }        bool left = true,right = true;        //判断左子树是否为二叉树        if(lefttree.size() &gt; 1){            left = VerifySquenceOfBST(lefttree);        }        //判断右子树是否为二叉树        if(righttree.size() &gt; 1){            right = VerifySquenceOfBST(righttree);        }        return (left &amp;&amp; right);    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从上往下打印二叉树</title>
      <link href="/posts/78.html"/>
      <url>/posts/78.html</url>
      
        <content type="html"><![CDATA[<h3 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h3><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考的是树的广度优先搜索，用的是队列来实现。</p><ul><li>将第一个元素加入队列</li><li>队列不为空时取队首元素，判断其是否有子节点，如果有则加入队列。</li><li>将取到的节点出队</li><li>转到第二步，直到队列为空</li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code>/*struct TreeNode {    int val;    struct TreeNode *left;    struct TreeNode *right;    TreeNode(int x) :            val(x), left(NULL), right(NULL) {    }};*/class Solution {public:    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) {        vector&lt;int&gt; arr;        if(root == nullptr)            return arr;        queue&lt;TreeNode*&gt; que;        que.push(root);        while(que.size()){            arr.push_back(que.front() -&gt; val);            if(que.front() -&gt; left != nullptr){                que.push(que.front() -&gt; left);            }            if(que.front() -&gt; right != nullptr){                que.push(que.front() -&gt; right);            }            que.pop();        }        return arr;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>客户端与服务端传数据-IntentServe类</title>
      <link href="/posts/30153.html"/>
      <url>/posts/30153.html</url>
      
        <content type="html"><![CDATA[<h2 id="客户端与服务端传数据-IntentServe类"><a href="#客户端与服务端传数据-IntentServe类" class="headerlink" title="客户端与服务端传数据-IntentServe类"></a>客户端与服务端传数据-IntentServe类</h2><h3 id="要求描述"><a href="#要求描述" class="headerlink" title="要求描述"></a>要求描述</h3><p>以IntentServer类为父类定义一个服务类，实现以下功能：</p><p>1、客户端通过Intent传递两个整数。</p><p>2、服务端获取从客户端传来的两个整数，并在服务端编写一个方法，该方法返回两个数之和。</p><h3 id="客户端MainActivity-java代码"><a href="#客户端MainActivity-java代码" class="headerlink" title="客户端MainActivity.java代码"></a>客户端MainActivity.java代码</h3><p>客户端通过Intent传递两个整数</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>gdlgxy<span class="token punctuation">.</span>intentservice<span class="token punctuation">;</span><span class="token keyword">import</span> androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AppCompatActivity<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>ComponentName<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>Context<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>Intent<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>ServiceConnection<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Bundle<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Handler<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>IBinder<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Message<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Messenger<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Log<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>Button<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Intent intent<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>MyIntentService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            intent<span class="token punctuation">.</span><span class="token function">putExtra</span><span class="token punctuation">(</span><span class="token string">"actio"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            intent<span class="token punctuation">.</span><span class="token function">putExtra</span><span class="token punctuation">(</span><span class="token string">"count"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">startService</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="服务端MyIntentService-java代码"><a href="#服务端MyIntentService-java代码" class="headerlink" title="服务端MyIntentService.java代码"></a>服务端MyIntentService.java代码</h3><p>服务端获取从客户端传来的两个整数，并在服务端编写一个方法，该方法返回两个数之和。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>gdlgxy<span class="token punctuation">.</span>intentservice<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>IntentService<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>Intent<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Log<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyIntentService</span> <span class="token keyword">extends</span> <span class="token class-name">IntentService</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 主要用于调用服务类构造器     *     * @param name 用于区分不同任务     */</span>    <span class="token keyword">public</span> <span class="token function">MyIntentService</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * AndroidManifest.xml配置清单需要配置     *     * @param     */</span>    <span class="token keyword">public</span> <span class="token function">MyIntentService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"action"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *主要重写该方法，在该方法内进行异步操作。     **/</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onHandleIntent</span><span class="token punctuation">(</span>Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String name <span class="token operator">=</span> intent<span class="token punctuation">.</span><span class="token function">getStringExtra</span><span class="token punctuation">(</span><span class="token string">"action"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> intent<span class="token punctuation">.</span><span class="token function">getIntExtra</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> intent<span class="token punctuation">.</span><span class="token function">getIntExtra</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">getresult</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"Download"</span><span class="token punctuation">,</span> <span class="token string">"result:"</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getresult</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//以下方法的重写，仅仅为了打印日志</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"Download"</span><span class="token punctuation">,</span> <span class="token string">"onDestroy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"Download"</span><span class="token punctuation">,</span> <span class="token string">"onCreate"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStart</span><span class="token punctuation">(</span>Intent intent<span class="token punctuation">,</span> <span class="token keyword">int</span> startId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span>intent<span class="token punctuation">,</span> startId<span class="token punctuation">)</span><span class="token punctuation">;</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"Download"</span><span class="token punctuation">,</span> <span class="token string">"onStart"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">onStartCommand</span><span class="token punctuation">(</span>Intent intent<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> startId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"Download"</span><span class="token punctuation">,</span> <span class="token string">"onStartCommand"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onStartCommand</span><span class="token punctuation">(</span>intent<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> startId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="结果图"><a href="#结果图" class="headerlink" title="结果图"></a>结果图</h3><p><img src="https://cdn.jsdelivr.net/gh/1224756742/imgs2/images/%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%9C%E5%9B%BE.png" alt="程序结果图"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务端 </tag>
            
            <tag> 客户端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的压入、弹出序列</title>
      <link href="/posts/38808.html"/>
      <url>/posts/38808.html</url>
      
        <content type="html"><![CDATA[<h3 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h3><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>模拟入栈出栈的过程，判断出栈序列是否正确。</p><ul><li><p>如果pushV中有数据，压入stack</p></li><li><p>如果stack的最后一个元素与popV中第一个元素相等，将两个元素都弹出</p></li><li><p>如果第一个元素相等，直接都弹出，根本不用压入stack</p></li><li><p>如果情况都不满足，false。</p></li></ul><pre><code>class Solution {public:    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) {        stack&lt;int&gt; a;        while(pushV.size()){            if(pushV[0]!=popV[0]&amp;&amp;(a.empty()||popV[0]!=a.top())){                 a.push(pushV[0]);                pushV.erase(pushV.begin());               }else if(pushV[0]==popV[0]){                pushV.erase(pushV.begin());                popV.erase(popV.begin());            }else if(!a.empty()&amp;&amp;popV[0]==a.top()){                a.pop();                popV.erase(popV.begin());            }        }        while(!a.empty())            {             if(popV[0]!=a.top())                 return false;            else{                 a.pop();                popV.erase(popV.begin());            }        }        return true;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包含min函数的栈</title>
      <link href="/posts/63137.html"/>
      <url>/posts/63137.html</url>
      
        <content type="html"><![CDATA[<h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><p>注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义一个辅助栈，每次压栈操作时, 如果压栈元素比当前最小元素更小, 就把这个元素压入最小元素栈, 原本的最小元素就成了次小元素.。同理, 弹栈时, 如果弹出的元素和最小元素栈的栈顶元素相等, 就把最小元素的栈顶弹出。</p><pre><code>class Solution {public:    stack&lt;int&gt; stack1,stack2;    void push(int value) {        stack1.push(value);        if(stack2.empty())            stack2.push(value);        else if(value&lt;=stack2.top())        {            stack2.push(value);        }    }    void pop() {        if(stack1.top()==stack2.top())            stack2.pop();        stack1.pop();    }    int top() {        return stack1.top();           }    int min() {        return stack2.top();    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺时针打印矩阵</title>
      <link href="/posts/54334.html"/>
      <url>/posts/54334.html</url>
      
        <content type="html"><![CDATA[<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>顺着走，即向右-&gt;向下-&gt;向左-&gt;向上，一共要走（长*宽）步。遇到边界就改变方向，当向上碰到顶的时候，四个边界都缩小。</p><pre><code>class Solution {public:    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) {        vector&lt;int&gt; arr;        if(matrix.size() &lt;= 0)            return arr;        int row = matrix.size();        int col = matrix[0].size();        int star = 0,end = row - 1,left = 0,right = col - 1;        while(star &lt;= end &amp;&amp; left &lt;= right){            for(int i = left;i &lt;= right;i++){                arr.push_back(matrix[star][i]);            }            for(int i = star + 1;i &lt;= end;i++){                arr.push_back(matrix[i][right]);            }            for(int i = right - 1;i &gt;= left &amp;&amp; star &lt; end;i--){                arr.push_back(matrix[end][i]);            }            for(int i = end - 1;i &gt; star &amp;&amp; right &gt; left;i--){                arr.push_back(matrix[i][left]);            }            star++;            end--;            left++;            right--;        }        return arr;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 矩阵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的镜像</title>
      <link href="/posts/24432.html"/>
      <url>/posts/24432.html</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>二叉树的镜像定义：源二叉树             8           /  \          6   10         / \  / \        5  7 9 11        镜像二叉树            8           /  \          10   6         / \  / \        11 9 7  5</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历二叉树的所有节点，如果遍历的节点有子节点，那么就交换遍历节点的子节点。交换完所有的节点就得到二叉树的镜像了。</p><p>递归思想。</p><pre><code>/*struct TreeNode {    int val;    struct TreeNode *left;    struct TreeNode *right;    TreeNode(int x) :            val(x), left(NULL), right(NULL) {    }};*/class Solution {public:    void Mirror(TreeNode *pRoot) {        if(pRoot == nullptr)            return;        if(pRoot -&gt; left == nullptr &amp;&amp; pRoot -&gt; right == nullptr)            return;        TreeNode *temp = pRoot -&gt; left;        pRoot -&gt;left = pRoot -&gt; right;        pRoot -&gt; right = temp;        if(pRoot -&gt; left){            Mirror(pRoot -&gt; left);        }        if(pRoot -&gt; right){            Mirror(pRoot -&gt; right);        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的子结构</title>
      <link href="/posts/59410.html"/>
      <url>/posts/59410.html</url>
      
        <content type="html"><![CDATA[<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>参考剑指offer的思路</p><ul><li><p>首先设置标志位result = false，因为一旦匹配成功result就设为true。如果匹配不成功，默认返回false</p></li><li><p>递归思想：如果根节点相同则递归调用DoesTree1HaveTree2（），<br>如果根节点不相同，则判断tree1的左子树和tree2是否相同，<br>再判断右子树和tree2是否相同</p></li><li><p>注意输入两棵树可能是空树的情况。</p></li></ul><pre><code>/*struct TreeNode {    int val;    struct TreeNode *left;    struct TreeNode *right;    TreeNode(int x) :            val(x), left(NULL), right(NULL) {    }};*/class Solution {public:    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)    {            bool result = false;            if(pRoot1 != nullptr &amp;&amp; pRoot2 != nullptr){                if(pRoot1-&gt;val == pRoot2-&gt;val){                    result = DoesTree1HaveTree2(pRoot1,pRoot2);                }                if(!result){result = HasSubtree(pRoot1-&gt;left, pRoot2);}                if(!result){result = HasSubtree(pRoot1-&gt;right, pRoot2);}            }            return result;    }    bool DoesTree1HaveTree2(TreeNode* root1,TreeNode* root2){            if(root1 == nullptr &amp;&amp; root2 != nullptr) return false;            if(root2 == nullptr) return true;            if(root1-&gt;val != root2-&gt;val) return false;            return DoesTree1HaveTree2(root1-&gt;left, root2-&gt;left) &amp;&amp; DoesTree1HaveTree2(root1-&gt;right, root2-&gt;right);        }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个排序的链表</title>
      <link href="/posts/14528.html"/>
      <url>/posts/14528.html</url>
      
        <content type="html"><![CDATA[<h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>链表表1的头结点的值小于链表2的头结点的值，因此链表1的头结点是合并后链表的头结点。在剩余的结点中，链表2的头结点的值小于链表1的头结点的值，因此链表2的头结点是剩余结点的头结点，把这个结点和之前已经合并好的链表的尾结点链接起来。</p><p><img src="https://uploadfiles.nowcoder.com/images/20170119/3111850_1484789893742_6903DA8DDE03E5B02CCB5F97FC3E53C2" alt="过程图"></p><pre><code>/*struct ListNode {    int val;    struct ListNode *next;    ListNode(int x) :            val(x), next(NULL) {    }};*/class Solution public:    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)    {        if(pHead1 == NULL)            return pHead2;        if(pHead2 == NULL)            return pHead1;        ListNode* rehead = nullptr;        if(pHead1 -&gt; val &gt; pHead2 -&gt; val){            rehead = pHead2;            rehead -&gt; next = Merge(pHead1,pHead2 -&gt; next);        }else{            rehead = pHead1;            rehead -&gt; next = Merge(pHead1 -&gt; next,pHead2);        }        return rehead;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/posts/967.html"/>
      <url>/posts/967.html</url>
      
        <content type="html"><![CDATA[<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，反转链表后，输出新链表的表头。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义三个指针分别指向当前遍历节点，当前节点的前一个节点，当前节点的后一个节点。</p><p><strong>注意：</strong>链表操作时，大意的话容易丢失当前节点的尾部。所以要确保尾部不丢失。</p><pre><code>/*struct ListNode {    int val;    struct ListNode *next;    ListNode(int x) :            val(x), next(NULL) {    }};*/class Solution {public:    ListNode* ReverseList(ListNode* pHead) {        ListNode* pnode = pHead;        ListNode* rehead = nullptr;        ListNode* pprev = nullptr;        while(pnode != NULL){            ListNode* pnext = pnode-&gt;next;            if(pnext == NULL){                rehead = pnode;            }            pnode-&gt;next = pprev;            pprev = pnode;            pnode = pnext;        }        return rehead;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表中倒数第k个结点</title>
      <link href="/posts/9631.html"/>
      <url>/posts/9631.html</url>
      
        <content type="html"><![CDATA[<h2 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个结点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历一遍链表，知道有多少个节点。再遍历一次找到目标节点。</p><pre><code>/*struct ListNode {    int val;    struct ListNode *next;    ListNode(int x) :            val(x), next(NULL) {    }};*/class Solution {public:    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {        if(k == 0 || pListHead == NULL) return NULL;        int n = 1;        ListNode* node = pListHead;        while (node -&gt; next != NULL){            n++;            node = node -&gt; next;        }        node = pListHead;        int l = n-k;        if (l &lt; 0)             return NULL;        while (l)            {            l--;            node = node -&gt; next;        }        return node;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调整数组顺序使奇数位于偶数前面</title>
      <link href="/posts/7691.html"/>
      <url>/posts/7691.html</url>
      
        <content type="html"><![CDATA[<h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>创建一个新数组，遍历传进的数组，先放奇数后放偶数。</p><pre><code>class Solution {public:    void reOrderArray(vector&lt;int&gt; &amp;array) {        vector&lt;int&gt; temp;        for(int i = 0;i &lt; array.size();i++){            if(array[i] % 2 == 1){                temp.push_back(array[i]);            }        }        for(int i = 0;i &lt; array.size();i++){            if(array[i] % 2 == 0){                temp.push_back(array[i]);            }        }        array = temp;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值的整数次方</title>
      <link href="/posts/15437.html"/>
      <url>/posts/15437.html</url>
      
        <content type="html"><![CDATA[<h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用递归，时间复杂度O(logn)</p><ul><li>当n为偶数，a^n =（a^n/2）*（a^n/2）</li></ul><ul><li>当n为奇数，a^n = a^[(n-1)/2] * a^[(n-1)/2] * a</li></ul><pre><code>class Solution {public:    double Power(double base, int exponent) {        int n = exponent;        if(exponent &lt; 0){           n = -exponent;        }        if(n==0)            return 1;        if(n==1)            return base;        double result=Power(base,n&gt;&gt;1);        result*=result;        if((n&amp;1)==1)            result*=base;        if(exponent&lt;0)            result=1/result;        return result;         }};</code></pre><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><ul><li>用右移运算符代替除以2</li><li>用位与运算符代替求余运算符来判断一个数是奇数还是偶数</li></ul><p>这样的效率会更高。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二进制中1的个数</title>
      <link href="/posts/61258.html"/>
      <url>/posts/61258.html</url>
      
        <content type="html"><![CDATA[<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>开始我的想法是把十进制数转换成二进制，二进制的每一位放进数组中，再循环遍历数组找出1的个数。</p><pre><code>class Solution {public:     int  NumberOf1(int n) {         vector&lt;int&gt; arr;         int temp = 0,count = 0;         while(n != 0){             temp = n % 2;             arr.push_back(temp);             n /= 2;         }         for(int i = 0;i &lt; arr.size();i++){             if(arr[i] == 1){                 count++;             }         }         return count;     }};</code></pre><p>但输入如果是负数的话，这程序就搞不了了。</p><pre><code>您的代码已保存答案错误:您提交的程序没有通过所有的测试用例点击对比用例标准输出与你的输出case通过率为44.44%用例:-2147483648对应输出应该为:1你的输出为:0</code></pre><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p><p>​      <strong>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作</strong>——–<strong>《剑指offer》</strong></p><pre><code>class Solution {public:     int  NumberOf1(int n) {        int count = 0;        while(n!= 0){            count++;            n = n &amp; (n - 1);         }        return count;     }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>矩阵覆盖</title>
      <link href="/posts/2894.html"/>
      <url>/posts/2894.html</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵覆盖"><a href="#矩阵覆盖" class="headerlink" title="矩阵覆盖"></a>矩阵覆盖</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p>比如n=3时，2*3的矩形块有3种覆盖方法：</p><p><img src="https://uploadfiles.nowcoder.com/images/20200218/6384065_1581999858239_64E40A35BE277D7E7C87D4DCF588BE84" alt="img"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>斐波那契数列的变种</p><ul><li>当你n=1，方法数：1</li><li>当你n=2，方法数：2</li><li>当你n=3，方法数：3</li><li>当你n=4，方法数：5</li><li>当你n=5，方法数：8</li></ul><p>f(n) = f(n-1)+f(n-2)</p><pre class=" language-c++"><code class="language-c++">class Solution {public:    int rectCover(int number) {        if(number < 1)            return 0;        else if(number == 1 || number == 2)            return number;        return rectCover(number - 1) + rectCover(number - 2);    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳台阶</title>
      <link href="/posts/62776.html"/>
      <url>/posts/62776.html</url>
      
        <content type="html"><![CDATA[<h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>斐波那契数列的变种，上递归代码。避免重复计算的做法可以参考我的上篇文章《斐波那契数列》</p><pre><code>class Solution {public:    int jumpFloor(int number) {        if(number == 1) return 1;        if(number == 2) return 2;        return jumpFloor(number - 1) + jumpFloor(number - 2);    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契数列</title>
      <link href="/posts/51227.html"/>
      <url>/posts/51227.html</url>
      
        <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</p><p>n&lt;=39</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>斐波那契数列的规律是前两项的和等于该项。看到这题就想到教科书上的递归解法。</p><pre><code>class Solution {public:    int Fibonacci(int n) {        if(n&lt;=0) return 0;         if(n==1 || n==2) return 1;        return Fibonacci(n-1)+Fibonacci(n-2);    }};</code></pre><p>但递归的做法，程序做了很多重复的计算。举个例子：n=4时</p><p>Fibonacci(4) = Fibonacci(3) + Fibonacci(2); </p><p>​            = Fibonacci(2) + Fibonacci(1) + Fibonacci(1)  + Fibonacci(0);</p><p>​            = Fibonacci(1) + Fibonacci(0) + Fibonacci(1)  + Fibonacci(1) + Fibonacci(0);</p><p>  由于我们的代码并没有记录Fibonacci(1)和Fibonacci(0)的结果，对于程序来说它每次递归都是未知的，因此光是n=4时f(1)就重复计算了3次之多。</p><p>更好的办法是从下往上算，根据Fibonacci(0)和Fibonacci(1)计算出Fibonacci(2)，再根据Fibonacci(1)和Fibonacci(2)计算出Fibonacci(3)……以此类推，这样就可以算出第n项了。</p><pre><code>class Solution {public:    int Fibonacci(int n) {        int arr[] = {0,1};        if(n &lt; 2){            return arr[n];        }        int one = 0,two = 1;        int temp = 0;        for(int i = 2;i &lt;= n;i++){            temp = one + two;            one = two;            two = temp;        }        return temp;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>旋转数组的最小数字</title>
      <link href="/posts/48940.html"/>
      <url>/posts/48940.html</url>
      
        <content type="html"><![CDATA[<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题可以直接遍历一遍找出数组中最小的数，但时间复杂度是O(n),用二分法的时间复杂度是O(logn)。</p><p>参考牛客网<a href="https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba?f=discussion" target="_blank" rel="noopener">FINACK</a>的做法。↓↓↓</p><p>采用二分法解答这个问题， </p><p>  mid = low + (high - low)/2 </p><p>  需要考虑三种情况： </p><p>  (1)array[mid] &gt; array[high]: </p><p>  出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。 </p><p>  low = mid + 1 </p><p>  (2)array[mid] == array[high]: </p><p>  出现这种情况的array类似 [1,0,1,1,1]   或者[1,1,1,0,1]，此时最小数字不好判断在mid左边 </p><p>  还是右边,这时只好一个一个试 ， </p><p>  high = high - 1 </p><p>  (3)array[mid] &lt; array[high]: </p><p>  出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左 </p><p>  边。因为右边必然都是递增的。 </p><p>  high = mid </p><p>  <strong>注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid</strong> <strong>一定会指向下标靠前的数字</strong>  </p><p>  比如 array = [4,6] </p><p>  array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ; </p><p>  如果high = mid - 1，就会产生错误， 因此high = mid </p><p>  但情形(1)中low = mid + 1就不会错误</p><pre><code>class Solution {public:    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) {        int leng = rotateArray.size();        int max = leng - 1,min = 0,mid = 0;        while(min &lt; max){            mid = (max + min) / 2;            if(rotateArray[mid] &gt; rotateArray[max]){                min = mid + 1;            }else if(rotateArray[mid] == rotateArray[max]){                max = max - 1;            }else{                max = mid;            }        }        return rotateArray[min];    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用两个栈实现队列</title>
      <link href="/posts/57550.html"/>
      <url>/posts/57550.html</url>
      
        <content type="html"><![CDATA[<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>栈：先进后出</p><p>队列：先进先出</p><ul><li><strong>入栈：</strong>现有两个空栈，将元素暂且放入栈1中。入队列操作。</li><li><strong>出栈：</strong>将栈1的元素全部压进栈2中，这样就翻转了栈1的元素。这是再将栈2顶部的元素出栈，就可以实现队列的出栈操作了。</li></ul><pre><code>class Solution{public:    void push(int node) {        stack1.push(node);    }    int pop() {        if(stack2.size() &lt;= 0){            while(stack1.size() != 0){                int temp = stack1.top();                stack2.push(temp);                stack1.pop();            }        }        int temp = stack2.top();        stack2.pop();        return temp;    }private:    stack&lt;int&gt; stack1;    stack&lt;int&gt; stack2;};</code></pre><h3 id="相关思考题"><a href="#相关思考题" class="headerlink" title="相关思考题"></a>相关思考题</h3><p>用两个队列实现一个栈的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重建二叉树</title>
      <link href="/posts/19604.html"/>
      <url>/posts/19604.html</url>
      
        <content type="html"><![CDATA[<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>前序遍历就是根在前，中序遍历就是根在中，后序遍历就是根在后。</p><p>树的遍历一般是用递归的方法。看前序遍历的结果，再结合中序遍历确定根节点。将根节点左右两边的序列又当成一棵树一直递归。因为中序左右子树的索引很好找。</p><p>接下来是确定递归结束的条件，遍历序列为空就结束。</p><pre class=" language-c++"><code class="language-c++">/** * Definition for binary tree * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {        TreeNode* root = reConstructBinaryTree(pre,0,pre.size() - 1,vin,0,vin.size() - 1);        return root;    }private:    TreeNode *reConstructBinaryTree(vector<int>& pre,int startpre,int endpre,vector<int>& vin,int startvin,int endvin){        if(startpre > endpre || startvin > endvin){            return NULL;        }        TreeNode *root = new TreeNode(pre[startpre]);        for(int i = startvin;i <= endvin;i++){            if(vin[i] == pre[startpre]){                root -> left=reConstructBinaryTree(pre,startpre+1,startpre+i-startvin,vin,startvin,i-1);                root -> right=reConstructBinaryTree(pre,i-startvin+startpre+1,endpre,vin,i+1,endvin);                break;            }        }        return root;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从尾到头打印链表</title>
      <link href="/posts/58399.html"/>
      <url>/posts/58399.html</url>
      
        <content type="html"><![CDATA[<h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>遍历链表，将节点的值放在数组里</li><li>再翻转数组即可</li></ul><pre><code>/***  struct ListNode {*        int val;*        struct ListNode *next;*        ListNode(int x) :*              val(x), next(NULL) {*        }*  };*/class Solution {public:    vector&lt;int&gt; printListFromTailToHead(ListNode* head) {        vector&lt;int&gt; arr;        if(head != NULL){            arr.push_back(head -&gt; val);            while(head -&gt; next != NULL){                arr.push_back(head -&gt; next -&gt; val);                head = head -&gt; next;            }        }        //for(int i = arr.size() - 1,j = 0;i &gt;= 0;i--,j++){            //temp[j] = arr[i];        //}        //arr.reserve(arr.begin(),arr.end());        //手动实现数组翻转        int i=0,j=arr.size()-1;        while(i&lt;j){            swap(arr[i],arr[j]);            i++;            j--;        }        return arr;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>替换空格</title>
      <link href="/posts/12603.html"/>
      <url>/posts/12603.html</url>
      
        <content type="html"><![CDATA[<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>新开辟字符串进行替换。</p><p>牛客传参的类型是char*，佛了。。。</p><pre><code>class Solution {public:    void replaceSpace(char *str,int length) {         string temp(str);        string res;        for(auto i :temp){            if(i == &#39; &#39;){                res += &quot;%20&quot;;            }else{                res += i;            }        }        auto ret = res.c_str();        strcpy(str,ret);     }};</code></pre><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>在当前字符串进行替换</p><ul><li>从前往后替换，后面的字符要不断往后移动，要多次移动，所以效率低下</li><li>从后往前，先计算需要多少空间，然后从后往前移动，则每个字符只为移动一次，这样效率更高一点。</li></ul><p><strong>注意：</strong>题目给的空间是足够的，不用担心</p><p>这里实现从后往前替换的方法</p><pre><code>class Solution {public:    void replaceSpace(char *str,int length) {         if(str == NULL || length &lt;0)            return;        int num =0;    //空格数目        for (int i = 0; i &lt; length; i++){            if (str[i] == &#39; &#39;)                num++;        }        int truelength = length + num * 2;  //字符串替换%20之后的长度        while(length &gt;= 0 &amp;&amp; truelength &gt; length){            if(str[length] == &#39; &#39;){                str[truelength--] = &#39;0&#39;;                str[truelength--] = &#39;2&#39;;                str[truelength--] = &#39;%&#39;;            }else{                str[truelength--] = str[length];            }            length--;        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组中的查找</title>
      <link href="/posts/45951.html"/>
      <url>/posts/45951.html</url>
      
        <content type="html"><![CDATA[<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为这个二维数组是左到右，上到下递增的。选取数组中的一个数和查找的数相比。</p><ul><li>如果选取数大于查找数，那么查找数必然在左边或下边</li><li>如果选取数小于查找数，那么查找数必然在右边或上边</li><li>如果选取数等于查找数，直接返回true</li></ul><p>这里选取数组右上角的数，如果选取数大于查找数，选取数这一列都不用查找了。如果大于查找数，再往下逐行查找。</p><pre><code>class Solution {public:    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) {        int col = array.size();        int row = array[0].size();        for(int i = col - 1,j = 0;i &gt;= 0 &amp;&amp; j &lt; row;){            if(target == array[i][j]){                return true;            }else if(target &gt; array[i][j]){                j++;            }else{                i--;            }        }        return false;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建安卓的基本通知</title>
      <link href="/posts/26648.html"/>
      <url>/posts/26648.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建安卓的基本通知"><a href="#创建安卓的基本通知" class="headerlink" title="创建安卓的基本通知"></a>创建安卓的基本通知</h2><p>1、为界面上一个图片设置弹出式菜单名为“发送通知”，当点击该菜单项则创建基本通知。</p><p>2、设置通知的“关闭”点按操作。</p><h3 id="popupmenu-xml"><a href="#popupmenu-xml" class="headerlink" title="popupmenu.xml"></a>popupmenu.xml</h3><p>创立一个popupmenu.xml文件，这个文件创建弹出式菜单的两个菜单项，分别是“发送菜单”和“返回”。</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menu</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>group</span> <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/group<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>            <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/actionmenu1<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>发送通知<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>            <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/actionmenu2<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>返回<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>group</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menu</span><span class="token punctuation">></span></span></code></pre><h3 id="activity-xml文件"><a href="#activity-xml文件" class="headerlink" title="activity.xml文件"></a>activity.xml文件</h3><p>在activity.xml文件中，加入一个imagView空间，放置图片</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.constraintlayout.widget.ConstraintLayout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>app</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res-auto<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>tools</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/tools<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">tools:</span>context</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.MainActivity<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ImageView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/imageView<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginStart</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>102dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginLeft</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>102dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginTop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>164dp<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintStart_toStartOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintTop_toTopOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>srcCompat</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@android:drawable/ic_notification_overlay<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.constraintlayout.widget.ConstraintLayout</span><span class="token punctuation">></span></span></code></pre><h3 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h3><p>在MainActivity.java文件中，先声明imagView控件和需要的变量，再为其实现个点击事件</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>gdlgxy<span class="token punctuation">.</span>menudemo<span class="token punctuation">;</span><span class="token keyword">import</span> androidx<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequiresApi<span class="token punctuation">;</span><span class="token keyword">import</span> androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AppCompatActivity<span class="token punctuation">;</span><span class="token keyword">import</span> androidx<span class="token punctuation">.</span>core<span class="token punctuation">.</span>app<span class="token punctuation">.</span>NotificationCompat<span class="token punctuation">;</span><span class="token keyword">import</span> androidx<span class="token punctuation">.</span>core<span class="token punctuation">.</span>app<span class="token punctuation">.</span>NotificationManagerCompat<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>Notification<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>NotificationChannel<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>NotificationManager<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>PendingIntent<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>Intent<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>BitmapFactory<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Build<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Bundle<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>ContextMenu<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>Menu<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>MenuInflater<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>MenuItem<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>SubMenu<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>ImageView<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>PopupMenu<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>TextView<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>Toast<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> androidx<span class="token punctuation">.</span>core<span class="token punctuation">.</span>app<span class="token punctuation">.</span>NotificationManagerCompat<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ImageView imageView<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String CHANNELID <span class="token operator">=</span> <span class="token string">"gdlgxy"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> notificationID <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明textview控件，注册上下文菜单</span>        <span class="token comment" spellcheck="true">//TextView textView = (TextView) findViewById(R.id.context_menu);</span>        <span class="token comment" spellcheck="true">//registerForContextMenu(textView);</span>        imageView <span class="token operator">=</span> <span class="token punctuation">(</span>ImageView<span class="token punctuation">)</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>imageView<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//点击图片弹出弹出式菜单，再点击菜单项发送通知，实现关闭通知</span>       imageView<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">View<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                PopupMenu popupMenu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PopupMenu</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>                MenuInflater menuInflater <span class="token operator">=</span> popupMenu<span class="token punctuation">.</span><span class="token function">getMenuInflater</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                menuInflater<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>menu<span class="token punctuation">.</span>popupmenu<span class="token punctuation">,</span> popupMenu<span class="token punctuation">.</span><span class="token function">getMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                popupMenu<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                popupMenu<span class="token punctuation">.</span><span class="token function">setOnMenuItemClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PopupMenu<span class="token punctuation">.</span>OnMenuItemClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@RequiresApi</span><span class="token punctuation">(</span>api <span class="token operator">=</span> Build<span class="token punctuation">.</span>VERSION_CODES<span class="token punctuation">.</span>O<span class="token punctuation">)</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onMenuItemClick</span><span class="token punctuation">(</span>MenuItem item<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">switch</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getItemId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">case</span> R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>actionmenu1<span class="token operator">:</span>                                Intent intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> MainActivity<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">// PendingIntent pendingIntent = PendingIntent.getActivity(MainActivity.this, 0, mIntent, 0);</span>                                PendingIntent pi <span class="token operator">=</span> PendingIntent<span class="token punctuation">.</span><span class="token function">getActivity</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> intent<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">//获取NotificationManager的实例  系统中的通知服务</span>                                NotificationManager manager <span class="token operator">=</span>                                        <span class="token punctuation">(</span>NotificationManager<span class="token punctuation">)</span> <span class="token function">getSystemService</span><span class="token punctuation">(</span>NOTIFICATION_SERVICE<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">//使用Builder来创建 notification对象  用support-v4库 兼容性更好</span>                                NotificationCompat<span class="token punctuation">.</span>Builder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NotificationCompat<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> CHANNELID<span class="token punctuation">)</span>                                        <span class="token comment" spellcheck="true">//丰富对象内容 设置标题 文字 时间 大图标 小图标</span>                                        <span class="token punctuation">.</span><span class="token function">setSmallIcon</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>mipmap<span class="token punctuation">.</span>ic_launcher<span class="token punctuation">)</span>                                        <span class="token punctuation">.</span><span class="token function">setContentTitle</span><span class="token punctuation">(</span><span class="token string">"假面骑士Kuuga"</span><span class="token punctuation">)</span>                                        <span class="token punctuation">.</span><span class="token function">setContentText</span><span class="token punctuation">(</span><span class="token string">"你的笑容由我来守护！"</span><span class="token punctuation">)</span>                                        <span class="token comment" spellcheck="true">//.setPriority(NotificationCompat.PRIORITY_DEFAULT)</span>                                        <span class="token punctuation">.</span><span class="token function">setContentIntent</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//当点击消息（通知）提供一个PendingIntent</span>                                        <span class="token punctuation">.</span><span class="token function">setShowWhen</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//设置事件发生的时间。面板中的通知按此时间排序。</span>                                        <span class="token punctuation">.</span><span class="token function">addAction</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>mipmap<span class="token punctuation">.</span>ic_launcher<span class="token punctuation">,</span> <span class="token string">"关闭"</span><span class="token punctuation">,</span> pi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加动作图标操作按钮</span>                                <span class="token comment" spellcheck="true">//显示通知 第一个参数是通知的id 保证 每条通知的id不同</span>                                Notification notification <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                manager<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span>notificationID<span class="token punctuation">,</span> notification<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                            <span class="token keyword">default</span><span class="token operator">:</span>                                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="结果图"><a href="#结果图" class="headerlink" title="结果图"></a>结果图</h3><p>程序运行后，点击界面中的图片控件，弹出弹出式菜单</p><p><img src="https://s1.ax1x.com/2020/05/01/JXcAit.jpg" alt="弹出式菜单"></p><p>点击“发送通知”，创建基本通知</p><p><img src="https://s1.ax1x.com/2020/05/01/JX65xU.jpg" alt="基本通知"></p><p>好啦，收工！！！</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 菜单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为机试结局篇</title>
      <link href="/posts/63606.html"/>
      <url>/posts/63606.html</url>
      
        <content type="html"><![CDATA[<h2 id="华为机试结局篇"><a href="#华为机试结局篇" class="headerlink" title="华为机试结局篇"></a>华为机试结局篇</h2><p><a href="https://www.nowcoder.com/ta/huawei" target="_blank" rel="noopener">华为机试</a>刷了近两个月终于刷完了。这套题练数组，字符串较多，关于链表，树，图这些数据结构的题偏少些，动态规划的也少。</p><p><img src="https://cdn.jsdelivr.net/gh/1224756742/imgs/images/%E6%8D%95%E8%8E%B7.PNG" alt="战绩"></p><p>有点惨。。。</p><p>有空去刷《剑指offer》了，冲鸭！！！</p>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>求最小公倍数</title>
      <link href="/posts/25368.html"/>
      <url>/posts/25368.html</url>
      
        <content type="html"><![CDATA[<h2 id="求最小公倍数"><a href="#求最小公倍数" class="headerlink" title="求最小公倍数"></a>求最小公倍数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>正整数A和正整数B 的最小公倍数是指 能被A和B整除的最小的正整数值，设计一个算法，求输入A和B的最小公倍数。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入两个正整数A和B。</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出A和B的最小公倍数。</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>5 7</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>35</code></pre><p>从1开始尝试，能同时对A和B取余结果为零的即时结果</p><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int A,B;    while(cin&gt;&gt;A&gt;&gt;B){        for(int i = 1;i &lt; 100000000;i++){            if(i % A == 0 &amp;&amp; i % B == 0){                cout&lt;&lt;i&lt;&lt;endl;                break;            }        }    }    return 0;}</code></pre><p>但这种方法算出来的时间复杂度太大了，来个舒服些的</p><p>*最小公倍数 = 两数之积除以最大公约数</p><pre><code>#include&lt;iostream&gt;using namespace std;int gcd(int A, int B) {    while(A%B){        int temp = A;        A = B;        B = temp % B;    }    return B;}int main(){    int A,B;    while(cin &gt;&gt; A &gt;&gt; B){        cout &lt;&lt; A*B/gcd(A,B) &lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>求解立方根</title>
      <link href="/posts/38686.html"/>
      <url>/posts/38686.html</url>
      
        <content type="html"><![CDATA[<h2 id="求解立方根"><a href="#求解立方根" class="headerlink" title="求解立方根"></a>求解立方根</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>•计算一个数字的立方根，不使用库函数</p><p>详细描述：</p><p>•接口说明</p><p>原型：</p><p>public static double getCubeRoot(double input)</p><p>输入:double 待求解参数</p><p>返回值:double 输入参数的立方根，保留一位小数</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>待求解参数 double类型</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输入参数的立方根 也是double类型</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>216</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>6.0</code></pre><ul><li>二分法求解</li></ul><pre><code>#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;double getCubeRoot(double num){    double min = 0,max = num,mid = 0;    while((max - min) &gt; 0.001){ //提高精度        mid = (min + max) / 2;        if(mid*mid*mid &gt; num){            max = mid;        }else if(mid*mid*mid &lt; num){            min = mid;        }else{            return mid;        }    }    return max;}int main(){    double num;    while(cin&gt;&gt;num){        cout&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;(double)getCubeRoot(num)&lt;&lt;endl;    }    return 0;}</code></pre><ul><li>牛顿迭代法</li></ul><pre><code>链接：https://www.nowcoder.com/questionTerminal/caf35ae421194a1090c22fe223357dca?f=discussion来源：牛客网#include&lt;iostream&gt;#include&lt;iomanip&gt;//牛顿法using namespace std;double newton(double a){    double x = 1;    while (((x*x*x - a) &gt;= 1e-7) || ((a - x*x*x) &gt;= 1e-7)){        x = (x - x / 3 + a / (3 * x*x));    }    return x;}int main(){    double num;    while (cin &gt;&gt; num){        cout &lt;&lt; setprecision(1) &lt;&lt; fixed &lt;&lt; newton(num) &lt;&lt; endl;    }    return 0;}</code></pre><ul><li>这里贴一个求解<strong>平方根</strong>非常牛叉的函数，来感受数学之美</li></ul><pre><code>class Solution {public:    int mySqrt(int x) {        float xhalf = 0.5f*x;        int i = *(int*)&amp;x;        i = 0x5f3759df - (i &gt;&gt; 1); // 计算第一个近似根        x = *(float*)&amp;i;        x = x*(1.5f - xhalf*x*x); // 牛顿迭代法        //x = 1/(x*x);        return x;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串分割</title>
      <link href="/posts/26533.html"/>
      <url>/posts/26533.html</url>
      
        <content type="html"><![CDATA[<h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>连续输入字符串(输出次数为N,字符串长度小于100)，请按长度为8拆分每个字符串后输出到新的字符串数组，</p><p>长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。</p><p>首先输入一个整数，为要输入的字符串个数。</p><p>例如：</p><p>输入：2</p><p>   abc</p><p>   12345789</p><p>输出：abc00000</p><p>   12345678</p><p>   90000000</p><p>接口函数设计如下:</p><p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>功能:存储输入的字符创</p><p>输入:字符串</p><p>输出:无</p><p>返回:0表示成功,其它返回-1<br><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p><p>int AddString(char <em>strValue);<br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em><br>功能:获取补位后的二维数组的长度</p><p>输入:无</p><p>输出:无</p><p>返回:二维数组长度<br><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p><p>int GetLength();</p><p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>功能:将补位后的二维数组，与输入的二维数组做比较</p><p>输入:strInput:输入二维数组,iLen：输入的二维数组的长度</p><p>输出:无</p><p>返回:若相等,返回0;不相等,返回-1.其它:-1;<br><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br>int ArrCmp(char strInput[][9],int iLen);</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>首先输入数字n，表示要输入多少个字符串。连续输入字符串(输出次数为N,字符串长度小于100)。</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>按长度为8拆分每个字符串后输出到新的字符串数组，长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>2abc123456789</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>abc000001234567890000000</code></pre><ul><li>不够八位的补零</li><li>超出八位的先输出前八位</li><li>超出八位的部分再进循环前面两个步骤</li></ul><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    int num;    while(cin&gt;&gt;num){        for(int i = 0;i &lt; num;i++){            string str;            cin&gt;&gt;str;            while(str.size() &gt; 0){                if(str.size() &lt; 8){                    str += &quot;0000000&quot;;                    cout&lt;&lt;str.substr(0,8)&lt;&lt;endl;                    str = &quot;&quot;;                }else{                    cout&lt;&lt;str.substr(0,8)&lt;&lt;endl;                    str = str.substr(8);                }            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符统计</title>
      <link href="/posts/7363.html"/>
      <url>/posts/7363.html</url>
      
        <content type="html"><![CDATA[<h2 id="字符统计"><a href="#字符统计" class="headerlink" title="字符统计"></a>字符统计</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如果统计的个数相同，则按照ASCII码由小到大排序输出 。如果有其他字符，则对这些字符不用进行统计。</p><p>实现以下接口：<br>输入一个字符串，对字符中的各个英文字符，数字，空格进行统计（可反复调用）<br>按照统计个数由多到少输出统计结果，如果统计的个数相同，则按照ASII码由小到大排序输出<br>清空目前的统计结果，重新统计<br>调用者会保证：<br>输入的字符串以‘\0’结尾。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入一串字符。</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>对字符中的各个英文字符（大小写分开统计），数字，空格进行统计，并按照统计个数由多到少输出,如果统计的个数相同，则按照ASII码由小到大排序输出 。如果有其他字符，则对这些字符不用进行统计。</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>aadddccddc</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>dca</code></pre><ul><li>用桶排序的想法，将ASCLL码0~256字符出现的次数记录在数组中，因为这个数组本身就是按ASCLL码的顺序来的排的。</li><li>找出其中的出现最多字符的出现次数max，递减max并循环查找等于max的字符，再输出出来就好啦</li></ul><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    string str;    while(cin&gt;&gt;str){        int arr[256] = {0};        int max = 0;        for(int i = 0;i &lt; str.size();i++){            arr[str[i]]++;            if(arr[str[i]] &gt; max){                max = arr[str[i]];            }        }        while(max){            for(int i = 0;i &lt; 256;i++){                char ch;                if(arr[i] == max){                    ch = (char)i;                    cout&lt;&lt;ch;                }            }            max--;        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入整型数组和排序标识，对其元素按照升序或降序进行排序</title>
      <link href="/posts/3110.html"/>
      <url>/posts/3110.html</url>
      
        <content type="html"><![CDATA[<h2 id="输入整型数组和排序标识，对其元素按照升序或降序进行排序"><a href="#输入整型数组和排序标识，对其元素按照升序或降序进行排序" class="headerlink" title="输入整型数组和排序标识，对其元素按照升序或降序进行排序"></a>输入整型数组和排序标识，对其元素按照升序或降序进行排序</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入整型数组和排序标识，对其元素按照升序或降序进行排序（一组测试用例可能会有多组数据）</p><p>接口说明</p><p>原型：</p><p>void sortIntegerArray(Integer[] pIntegerArray, int iSortFlag);</p><p>输入参数：</p><p>Integer[] pIntegerArray：整型数组</p><p>int iSortFlag：排序标识：0表示按升序，1表示按降序</p><p>输出参数：</p><p>无</p><p>返回值：</p><p>void</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>1、输入需要输入的整型数个数</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出排好序的数字</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>81 2 4 9 3 55 64 250</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>1 2 3 4 9 25 55 64</code></pre><p>很普通的排序题</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main(){    int num;    while(cin&gt;&gt;num){        vector&lt;int&gt; arr(num,0);        for(int i = 0;i &lt; num;i++){            cin&gt;&gt;arr[i];        }        sort(arr.begin(),arr.end());        int flag;        cin&gt;&gt;flag;        if(flag == 0){            for(int i = 0;i &lt; arr.size();i++){                cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;            }            cout&lt;&lt;endl;        }else{            for(int i = arr.size() - 1; i &gt;= 0;i--){                cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;            }            cout&lt;&lt;endl;        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自守数</title>
      <link href="/posts/54966.html"/>
      <url>/posts/54966.html</url>
      
        <content type="html"><![CDATA[<h2 id="自守数"><a href="#自守数" class="headerlink" title="自守数"></a>自守数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>自守数是指一个数的平方的尾数等于该数自身的自然数。例如：25^2 = 625，76^2 = 5776，9376^2 = 87909376。请求出n以内的自守数的个数</p><p>接口说明</p><p>/*<br>功能: 求出n以内的自守数的个数</p><p>输入参数：<br>int n</p><p>返回值：<br>n以内自守数的数量。<br>*/</p><p>public static int CalcAutomorphicNumbers( int n)<br>{<br>/<em>在这里实现功能</em>/</p><p>return 0;<br>}</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>int型整数</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>n以内自守数的数量。</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>2000</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>8</code></pre><p>以数本身为循环次数，分别拿该数和平方后的各位数。比较拿出来的数字都相等，那么该数就是自守数。</p><pre><code>#include&lt;iostream&gt;using namespace std;bool isAutomorphic(int x){    int y=x*x;    while(x)    {        if(x%10==y%10)        {            x/=10;            y/=10;        }        else break;    }    if(x==0)         return true;    else         return  false;}int main(){    int num;    while(cin&gt;&gt;num)    {         bool flag;         int count=0;         for(int i = 0;i &lt; num;i++)         {             if(isAutomorphic(i))                  count++;         }        cout&lt;&lt;count&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符逆序</title>
      <link href="/posts/29758.html"/>
      <url>/posts/29758.html</url>
      
        <content type="html"><![CDATA[<h2 id="字符逆序"><a href="#字符逆序" class="headerlink" title="字符逆序"></a>字符逆序</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串str的内容颠倒过来，并输出。str的长度不超过100个字符。 如：输入“I am a student”，输出“tneduts a ma I”。</p><p>输入参数：</p><p>inputString：输入的字符串</p><p> 返回值：</p><p>输出转换好的逆序字符串</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入一个字符串，可以有空格</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出逆序的字符串</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>I am a student</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>tneduts a ma I</code></pre><p>将字符串逆过来输入就完事了</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    string str;    while(getline(cin,str)){        for(int i = str.size() - 1;i &gt;= 0;i--){            cout&lt;&lt;str[i];        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等差数列</title>
      <link href="/posts/4704.html"/>
      <url>/posts/4704.html</url>
      
        <content type="html"><![CDATA[<h2 id="等差数列"><a href="#等差数列" class="headerlink" title="等差数列"></a>等差数列</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>功能:等差数列 2，5，8，11，14。。。。</p><p>输入:正整数N &gt;0</p><p>输出:求等差数列前N项和</p><p>返回:转换成功返回 0 ,非法输入与异常返回-1</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入一个正整数。</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出一个相加后的整数。</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>2</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>真.等差数列。一点坑都没有。。。</p><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int num;    while(cin&gt;&gt;num){        int add = 2,sum=0;        for(int i = 0;i &lt; num;i++){            sum += add;            add +=3;        }        cout&lt;&lt;sum&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记负均正II</title>
      <link href="/posts/39257.html"/>
      <url>/posts/39257.html</url>
      
        <content type="html"><![CDATA[<h2 id="记负均正II"><a href="#记负均正II" class="headerlink" title="记负均正II"></a>记负均正II</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>从输入任意个整型数，统计其中的负数个数并求所有非负数的平均值</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入任意个整数</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出负数个数以及所有非负数的平均值</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>-13-4-7</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>30.0</code></pre><p>和上一篇记负均正差别不大</p><pre><code>#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main(){    int num;    int count1 = 0,count2 = 0,sum = 0;    while(cin&gt;&gt;num){        if(num &lt; 0){            count1++;        }else{            count2++;            sum += num;        }    }    cout&lt;&lt;count1&lt;&lt;endl&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;(double)sum/count2&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记负均正</title>
      <link href="/posts/5527.html"/>
      <url>/posts/5527.html</url>
      
        <content type="html"><![CDATA[<h2 id="记负均正"><a href="#记负均正" class="headerlink" title="记负均正"></a>记负均正</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>首先输入要输入的整数个数n，然后输入n个整数。输出为n个整数中负数的个数，和所有正整数的平均值，结果保留一位小数。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>首先输入一个正整数n，然后输入n个整数。</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出负数的个数，和所有正整数的平均值。</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>512345</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>0 3</code></pre><p><strong>注意</strong>：零不要计算进去</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;iomanip&gt;using namespace std;int main(){    int num;    while(cin&gt;&gt;num){        vector&lt;int&gt; arr(num);        int count1 = 0,count2 = 0;        double sum = 0;        for(int i = 0;i &lt; num;i++){            cin&gt;&gt;arr[i];            if(arr[i] &lt; 0){                count1++;            }else if(arr[i] &gt; 0){                count2++;                sum += arr[i];            }        }        cout&lt;&lt;count1&lt;&lt;&quot; &quot;&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;(double)sum/count2&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>表示数字</title>
      <link href="/posts/4365.html"/>
      <url>/posts/4365.html</url>
      
        <content type="html"><![CDATA[<h2 id="表示数字"><a href="#表示数字" class="headerlink" title="表示数字"></a>表示数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>将一个字符中所有出现的数字前后加上符号“*”，其他字符保持不变<br>public static String MarkNum(String pInStr)<br>{</p><p>return null;</p><p>}</p><p>注意：输入数据可能有多行</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入一个字符串</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>字符中所有出现的数字前后加上符号“*”，其他字符保持不变</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>Jkdi234klowe90a3</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>Jkdi*234*klowe*90*a*3*</code></pre><p>通过观察”**“号插入的位置，分四种情况讨论：</p><ul><li><p>数字和字母之间插入</p></li><li><p>字母和数字之间插入</p></li><li><p>第一个字符是数字时，在其前面插入</p></li><li><p>最后一个字符是数字时，在其后面插入</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    string str;    while(cin&gt;&gt;str){        int leng = str.size();        for(int i = 0;i &lt; leng - 1;i++){            //在数字和字母之间插入           if((str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;) &amp;&amp; ((str[i + 1] &gt;= &#39;a&#39; &amp;&amp; str[i + 1] &lt;= &#39;z&#39;) || (str[i+1] &gt;= &#39;A&#39; &amp;&amp; str[i + 1] &lt;= &#39;Z&#39;))){               str.insert(i + 1,&quot;*&quot;);               leng++;           }            //在字母和数字之间插入           if((str[i + 1] &gt;= &#39;0&#39; &amp;&amp; str[i + 1] &lt;= &#39;9&#39;) &amp;&amp; ((str[i] &gt;= &#39;a&#39; &amp;&amp; str[i] &lt;= &#39;z&#39;) || (str[i] &gt;= &#39;A&#39; &amp;&amp; str[i] &lt;= &#39;Z&#39;))){               str.insert(i + 1,&quot;*&quot;);               leng++;           }        }        string temp = str;        //头尾是数字的情况插入        if(str[0] &gt;= &#39;0&#39;&amp;&amp; str[0] &lt;= &#39;9&#39;){                temp = &#39;*&#39; + temp;            }        if(str[str.size() - 1] &gt;= &#39;0&#39; &amp;&amp; str[str.size() - 1] &lt;= &#39;9&#39;){                temp = temp + &#39;*&#39;;            }        cout&lt;&lt;temp&lt;&lt;endl;    }    return 0;}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记票统计</title>
      <link href="/posts/37310.html"/>
      <url>/posts/37310.html</url>
      
        <content type="html"><![CDATA[<h2 id="记票统计"><a href="#记票统计" class="headerlink" title="记票统计"></a>记票统计</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现接口：</p><p>unsigned int AddCandidate (char* pCandidateName);<br>功能：设置候选人姓名<br>输入： char* pCandidateName 候选人姓名<br>输出：无<br>返回：输入值非法返回0，已经添加过返回0 ，添加成功返回1</p><p>Void Vote(char* pCandidateName);<br>功能：投票<br>输入： char* pCandidateName 候选人姓名<br>输出：无<br>返回：无</p><p>unsigned int GetVoteResult (char* pCandidateName);</p><p>功能：获取候选人的票数。如果传入为空指针，返回无效的票数，同时说明本次投票活动结束，释放资源<br>输入： char* pCandidateName 候选人姓名。当输入一个空指针时，返回无效的票数</p><p>输出：无<br>返回：该候选人获取的票数</p><p>void Clear()</p><p>// 功能：清除投票结果，释放所有资源<br>// 输入：<br>// 输出：无<br>// 返回</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入候选人的人数，第二行输入候选人的名字，第三行输入投票人的人数，第四行输入投票。</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>每行输出候选人的名字和得票数量。</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>4A B C D8A B C D E F G H</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>A : 1B : 1C : 1D : 1Invalid : 4</code></pre><ul><li><p>输入候选人</p></li><li><p>判断投票</p></li><li><p>输出结果</p><p>思想类似桶排序</p></li></ul><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main(){    int numbers;    while(cin&gt;&gt;numbers){        int count[10000] = {0};        vector&lt;string&gt; arr(numbers);        //输入候选人        for(int i = 0;i &lt; numbers;i++){            cin&gt;&gt;arr[i];        }        int ticket;        cin&gt;&gt;ticket;        vector&lt;string&gt; voter(ticket);        //输入票数        for(int i = 0;i &lt; ticket;i++){            cin&gt;&gt;voter[i];        }        //判断投票        for(int i = 0;i &lt; numbers;i++){            for(int j = 0;j &lt; ticket;j++){                if(arr[i] == voter[j]){                    count[i] += 1;                }            }        }        //输出结果        int invalid = 0;        for(int i = 0;i &lt; numbers;i++){            invalid += count[i];            cout&lt;&lt;arr[i]&lt;&lt;&quot;:&quot;&lt;&lt;count[i]&lt;&lt;endl;        }        cout&lt;&lt;&quot;Invalid :&quot;&lt;&lt;ticket - invalid&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串中找出连续最长的数字串</title>
      <link href="/posts/34408.html"/>
      <url>/posts/34408.html</url>
      
        <content type="html"><![CDATA[<h2 id="字符串中找出连续最长的数字串"><a href="#字符串中找出连续最长的数字串" class="headerlink" title="字符串中找出连续最长的数字串"></a>字符串中找出连续最长的数字串</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>样例输出</p><p>输出123058789，函数返回值9</p><p>输出54761，函数返回值5</p><p>接口说明</p><p>函数原型：</p><p>  unsignedint Continumax(char<em>* pOutputstr, char</em> intputstr)</p><p>输入参数：<br>  char* intputstr 输入字符串；</p><p>输出参数：<br>  char** pOutputstr: 连续最长的数字串，如果连续最长的数字串的长度为0，应该返回空字符串；如果输入字符串是空，也应该返回空字符串； </p><p>返回值：<br> 连续最长的数字串的长度</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入一个字符串。</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出字符串中最长的数字字符串和它的长度。如果有相同长度的串，则要一块儿输出，但是长度还是一串的长度</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>abcd12345ed125ss123058789</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>123058789,9</code></pre><ul><li>字符串分组，数字的全部放进容器里</li><li>找出最长的数字串的长度</li><li>找出最长的数字串并输出</li></ul><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main(){    string str;    while(cin&gt;&gt;str){        int max = 0;        vector&lt;string&gt; arr;        string temp;        //字符串分组，数字的全部放进容器里        for(int i = 0;i &lt; str.size();i++){            if(str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;){                temp += str[i];            }else{                arr.push_back(temp);                temp =&quot;&quot;;            }        }        //不要忘记把最后一组放进去哟        arr.push_back(temp);        //找出最长的数字串的长度        for(int i = 0;i &lt; arr.size();i++){            max = arr[i].size() &gt; max ? arr[i].size():max;        }        //找出最长的数字串并输出        for(int i = 0;i &lt;arr.size();i++){            if(arr[i].size() == max){                cout&lt;&lt;arr[i];            }        }        cout&lt;&lt;&quot;,&quot;&lt;&lt;max&lt;&lt;endl;        arr.clear();    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>201301-JAVA题目2-3级</title>
      <link href="/posts/54020.html"/>
      <url>/posts/54020.html</url>
      
        <content type="html"><![CDATA[<h2 id="201301-JAVA题目2-3级"><a href="#201301-JAVA题目2-3级" class="headerlink" title="201301-JAVA题目2-3级"></a>201301-JAVA题目2-3级</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请编写一个函数（允许增加子函数），计算n x m的棋盘格子（n为横向的格子数，m为竖向的格子数）沿着各自边缘线从左上角走到右下角，总共有多少种走法，要求不能走回头路，即：只能往右和往下走，不能往左和往上走。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入两个正整数</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>返回结果</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>22</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>6</code></pre><p>动态规划做法，将格子化成点，比如题目的2*2的例子</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>列和行交叉的点都是可以按规则走的。从(m, n)—&gt;(0, 0)就分两步走：</p><p>往右走一步：f(m, n - 1)—&gt;(0, 0) 加上下走一步：f(m - 1, n)—&gt;(0, 0)，可以开工码了，冲！！！</p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() {    int m, n;    while (cin &gt;&gt; m &gt;&gt; n) {        vector&lt;vector&lt;int&gt; &gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0));        for (int i = 0; i &lt;= n; i++) {            for (int j = 0; j &lt;= m; j++) {                if (i == 0 || j == 0) {                    dp[i][j] = 1;                    continue;                } else {                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];                }            }        }        cout &lt;&lt; dp[n][m] &lt;&lt; endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>合法IP</title>
      <link href="/posts/9288.html"/>
      <url>/posts/9288.html</url>
      
        <content type="html"><![CDATA[<h2 id="合法IP"><a href="#合法IP" class="headerlink" title="合法IP"></a>合法IP</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>现在IPV4下用一个32位无符号整数来表示，一般用点分方式来显示，点将IP地址分成4个部分，每个部分为8位，表示成一个无符号整数（因此不需要用正号出现），如10.137.17.1，是我们非常熟悉的IP地址，一个IP地址串中没有空格出现（因为要表示成一个32数字）。</p><p>现在需要你用程序来判断IP是否合法。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入一个ip地址</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>返回判断的结果YES or NO</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>10.138.15.1</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>YES</code></pre><p>IP地址本身就有格式限制，每八位在0到255之间，但前八位要大于零。接下来就是判断格式就可以了。</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;sint main(){    int arr[4] = {0};    char ch[3];    while(cin&gt;&gt;arr[0]&gt;&gt;ch[0]&gt;&gt;arr[1]&gt;&gt;ch[1]&gt;&gt;arr[2]&gt;&gt;ch[2]&gt;&gt;arr[3]){        if((arr[0] &gt; 0 &amp;&amp; arr[0] &lt;= 255) &amp;&amp; (arr[1] &gt;= 0 &amp;&amp; arr[1] &lt;= 255) &amp;&amp; (arr[2] &gt;= 0 &amp;&amp; arr[2] &lt;= 255) &amp;&amp; (arr[3] &gt;= 0 &amp;&amp; arr[3] &lt;= 255)){            if(ch[0] == &#39;.&#39; &amp;&amp; ch[1] == &#39;.&#39; &amp;&amp; ch[2] == &#39;.&#39;){                cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;            }else{                cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;            }        }else{            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>求最大连续bit数</title>
      <link href="/posts/33736.html"/>
      <url>/posts/33736.html</url>
      
        <content type="html"><![CDATA[<h2 id="求最大连续bit数"><a href="#求最大连续bit数" class="headerlink" title="求最大连续bit数"></a>求最大连续bit数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>功能: 求一个byte数字对应的二进制数字中1的最大连续数，例如3的二进制为00000011，最大连续2个1</p><p>输入: 一个byte型的数字</p><p>输出: 无</p><p>返回: 对应的二进制数字中1的最大连续数</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入一个byte数字</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出转成二进制之后连续1的个数</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>3</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>2</code></pre><ul><li>先将十进制数转化成二进制数，这属于基本操作了。</li><li>遍历数组，找到连续个1的最大。</li><li>不要忘记代码中 j+1的那个1。因为我们一直记录的是j+1之前的1的个数。</li></ul><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int num;    while(cin&gt;&gt;num){        int arr[100] = {0};        int i = 0, count = 0, max = 0;        //将十进制数字转化成二进制数存放在数组中        while(num != 0){            arr[i++] = num % 2;            num /= 2;        }        //遍历数组，找到连续个1的最大        for(int j = 0;j &lt; 99;j++){            if(arr[j] == 1 &amp;&amp; arr[j + 1] == 1){                count++;            }else{                if(count &gt; max){                    max = count;                    count = 0;                }            }        }        //别忘记j+1的那个1哟        cout&lt;&lt;max + 1&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串截取-密码截取</title>
      <link href="/posts/38562.html"/>
      <url>/posts/38562.html</url>
      
        <content type="html"><![CDATA[<h2 id="字符串运用-字符截取"><a href="#字符串运用-字符截取" class="headerlink" title="字符串运用-字符截取"></a>字符串运用-字符截取</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Catcher 是MCA国的情报员，他工作时发现敌国会用一些对称的密码进行通信，比如像这些ABBA，ABA，A，123321，但是他们有时会在开始或结束时加入一些无关的字符以防止别国破解。比如进行下列变化 ABBA-&gt;12ABBA,ABA-&gt;ABAKK,123321-&gt;51233214　。因为截获的串太长了，而且存在多种可能的情况（abaaab可看作是aba,或baaab的加密形式），Cathcer的工作量实在是太大了，他只能向电脑高手求助，你能帮Catcher找出最长的有效密码串吗？</p><p>（注意：记得加上while处理多个测试用例）</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入一个字符串</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>返回有效密码串的最大长度</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>ABBA</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>4</code></pre><p>分奇偶情况讨论，比如ABA，ABBA，满足情况，左右指针向外移动。</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    string str;    while(getline(cin,str)){        int len = str.size();        if(len&lt;=1)        {            //cout&lt;&lt;len&lt;&lt;endl;            continue;        }        int num = 1;        for(int i=1;i&lt;len-1;i++)        {            if(str[i]==str[i+1])            {//偶数对成                int curnum = 0;                int start = i;int end =i+1;                while(start&gt;=0 &amp;&amp; end&lt;=len &amp;&amp; str[start] == str[end])                {                    start--;                    end++;                    curnum+=2;                }                if(curnum&gt;num)                    num = curnum;            }            if(str[i-1]==str[i+1])            {//奇数对成                int curnum = 1;                int start = i-1;int end =i+1;                while(start&gt;=0 &amp;&amp; end&lt;=len &amp;&amp; str[start] == str[end])                {                    start--;                    end++;                    curnum+=2;                }                if(curnum&gt;num)                    num = curnum;            }        }        cout&lt;&lt;num&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓菜单组件的实现</title>
      <link href="/posts/26899.html"/>
      <url>/posts/26899.html</url>
      
        <content type="html"><![CDATA[<h2 id="安卓菜单组件的实现"><a href="#安卓菜单组件的实现" class="headerlink" title="安卓菜单组件的实现"></a>安卓菜单组件的实现</h2><h3 id="选项菜单的-xml代码"><a href="#选项菜单的-xml代码" class="headerlink" title="选项菜单的.xml代码"></a>选项菜单的.xml代码</h3><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menu</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/new_game<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/abc_vector_test<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/app_name<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/help<span class="token punctuation">"</span></span>          <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>help<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menu</span><span class="token punctuation">></span></span></code></pre><h3 id="上下文菜单的-xml代码"><a href="#上下文菜单的-xml代码" class="headerlink" title="上下文菜单的.xml代码"></a>上下文菜单的.xml代码</h3><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menu</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/menu1<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>初代<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/menu2<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>赛文<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/menu3<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>杰克<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/menu4<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>艾斯<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menu</span><span class="token punctuation">></span></span></code></pre><h3 id="MainActiviity-java代码"><a href="#MainActiviity-java代码" class="headerlink" title="MainActiviity.java代码"></a>MainActiviity.java代码</h3><p>各功能已写好注释，选项菜单中有子菜单，上下文菜单也写好了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>gdlgxy<span class="token punctuation">.</span>menudemo<span class="token punctuation">;</span><span class="token keyword">import</span> androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AppCompatActivity<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Bundle<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>ContextMenu<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>Menu<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>MenuInflater<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>MenuItem<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>SubMenu<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>TextView<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>Toast<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明textview控件，注册上下文菜单</span>        TextView textView <span class="token operator">=</span> <span class="token punctuation">(</span>TextView<span class="token punctuation">)</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>context_menu<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">registerForContextMenu</span><span class="token punctuation">(</span>textView<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//选项菜单中创建两个子菜单，分别是泰罗奥特曼和梦比优斯奥特曼</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onCreateOptionsMenu</span><span class="token punctuation">(</span>Menu menu<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SubMenu s1<span class="token operator">=</span>menu<span class="token punctuation">.</span><span class="token function">addSubMenu</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"泰罗奥特曼"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s1<span class="token punctuation">.</span><span class="token function">setHeaderTitle</span><span class="token punctuation">(</span><span class="token string">"技能"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置子菜单标题</span>        s1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"斯特流姆光线"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"箭形光线"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"泰罗大火焰"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"禁术：奥特炸弹"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SubMenu s2<span class="token operator">=</span>menu<span class="token punctuation">.</span><span class="token function">addSubMenu</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"梦比优斯奥特曼"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s2<span class="token punctuation">.</span><span class="token function">setHeaderTitle</span><span class="token punctuation">(</span><span class="token string">"技能"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"梦比姆射线"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"梦比姆光剑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"梦比姆爆裂"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"梦比姆回旋飞踢"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreateOptionsMenu</span><span class="token punctuation">(</span>menu<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//设置点击事件，弹出信息给人类</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onOptionsItemSelected</span><span class="token punctuation">(</span>MenuItem item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getGroupId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//判断分组</span>            <span class="token keyword">switch</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getItemId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>                    Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"释放斯特流姆光线"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>                    Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"释放箭形光线"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>                    Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"释放泰罗大火焰"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>                    Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"赌上性命的战斗，奥特炸弹"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getGroupId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">switch</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getItemId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>                    Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"释放梦比姆光线"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>                    Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"使用梦比姆光剑"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>                    Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"释放梦比姆爆裂"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>                    Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"释放梦比姆回旋飞踢"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onOptionsItemSelected</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//上下文菜单</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCreateContextMenu</span><span class="token punctuation">(</span>ContextMenu menu<span class="token punctuation">,</span> View v<span class="token punctuation">,</span> ContextMenu<span class="token punctuation">.</span>ContextMenuInfo menuInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreateContextMenu</span><span class="token punctuation">(</span>menu<span class="token punctuation">,</span> v<span class="token punctuation">,</span> menuInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * 添加菜单项xml文件         */</span>        MenuInflater inflater<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">MenuInflater</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        inflater<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>menu<span class="token punctuation">.</span>contextmenu<span class="token punctuation">,</span> menu<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * ContextMenu事件处理     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onContextItemSelected</span><span class="token punctuation">(</span>MenuItem item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getItemId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>menu1<span class="token operator">:</span>                Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"初代与你并肩作战"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>menu2<span class="token operator">:</span>                Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"赛文与你并肩作战"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>menu3<span class="token operator">:</span>                Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"杰克与你并肩作战"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>menu4<span class="token operator">:</span>                Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"艾斯与你并肩作战"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onContextItemSelected</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * 测试事件     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">Toastmake</span><span class="token punctuation">(</span><span class="token keyword">int</span> itemid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"你点击了上下文菜单"</span><span class="token operator">+</span>itemid<span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="App运行之后的部分效果图"><a href="#App运行之后的部分效果图" class="headerlink" title="App运行之后的部分效果图"></a>App运行之后的部分效果图</h3><p><strong>注意</strong>上下文菜单一定要记得长按哟！！！</p><p><img src="https://cdn.jsdelivr.net/gh/1224756742/imgs/images/E76E12F613CA4CD19E93FF3B0F7DBCD4.jpg" alt="教官与梦比优斯"></p><p><img src="https://cdn.jsdelivr.net/gh/1224756742/imgs/images/4CD579096650FC588F8B88450263DFB1.jpg" alt="泰罗"></p><p><img src="https://s1.ax1x.com/2020/04/22/JYV4OO.jpg" alt="奥特兄弟"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jsdeliver的使用方法</title>
      <link href="/posts/29181.html"/>
      <url>/posts/29181.html</url>
      
        <content type="html"><![CDATA[<h2 id="Jsdeliver的使用方法"><a href="#Jsdeliver的使用方法" class="headerlink" title="Jsdeliver的使用方法"></a>Jsdeliver的使用方法</h2><p>格式：<a href="https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</a><br>例如：<a href="https://cdn.jsdelivr.net/gh/1224756742/cdn@1.0/README.md" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/1224756742/cdn@1.0/README.md</a></p><p>如果以后在向cdn库里添加或者修改文件，首先把文件添加到本地仓库，然后依次在本地cdn仓库文件位置执行以下命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull origin master  <span class="token comment" spellcheck="true">#拉取远程仓库到本地</span><span class="token function">git</span> add <span class="token keyword">.</span><span class="token function">git</span> commit -m <span class="token string">'描述内容'</span><span class="token function">git</span> push origin master  <span class="token comment" spellcheck="true"># 推送到GitHub仓库</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Jsdeliver </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>统计大写字母个数</title>
      <link href="/posts/42196.html"/>
      <url>/posts/42196.html</url>
      
        <content type="html"><![CDATA[<h2 id="统计大写字母个数"><a href="#统计大写字母个数" class="headerlink" title="统计大写字母个数"></a>统计大写字母个数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>找出给定字符串中大写字符(即’A’-‘Z’)的个数</p><p>接口说明</p><p>原型：int CalcCapital(String str);</p><p>返回值：int</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入一个String数据</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出string中大写字母的个数</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>add123#$%#%#O</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>1</code></pre><p>用了个蠢方法，还是O(n*n)的时间复杂度(吐血)。。。</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    string str;    string strbig = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;    while(cin&gt;&gt;str){        int count = 0;        for(int i = 0;i &lt; 26;i++){            for(int j = 0;j &lt; str.size();j++){                if(str[j] == strbig[i]){                    count++;                }            }        }        cout&lt;&lt;count&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将真分数分解为埃及分数</title>
      <link href="/posts/58258.html"/>
      <url>/posts/58258.html</url>
      
        <content type="html"><![CDATA[<h2 id="将真分数分解为埃及分数"><a href="#将真分数分解为埃及分数" class="headerlink" title="将真分数分解为埃及分数"></a>将真分数分解为埃及分数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>分子为1的分数称为埃及分数。现输入一个真分数(分子比分母小的分数，叫做真分数)，请将该分数分解为埃及分数。如：8/11 = 1/2+1/5+1/55+1/110。</p><p>接口说明</p><p> /*<br> 功能: 将分数分解为埃及分数序列<br> 输入参数：<br>   String pcRealFraction:真分数(格式“8/11”)<br> 返回值：<br>   String pcEgpytFraction:分解后的埃及分数序列(格式“1/2+1/5+1/55+1/100”)<br> */</p><p> public static String ConvertRealFractToEgpytFract(String pcRealFraction)<br> {<br> return null;<br> }</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入一个真分数，String型</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出分解后的string</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>8/11</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>1/2+1/5+1/55+1/110</code></pre><p>设num1,num2为互质正整数，num1&lt;num2 分数num1/num2 可用以下的步骤分解成若干个单位分数之和：<br> 步骤一： 用num2除以num1，得商数q1及余数r1,即num2=num1*q1+r1<br> 步骤二： num1/num2=1/(q1+1）+(num1-r)/num2(q1+1）<br> 步骤三： 重复步骤2，直到分解完毕</p><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    char ch;    int num1, num2;    while (cin &gt;&gt; num1 &gt;&gt; ch &gt;&gt; num2)    {        while (num1 != 1)         {             if(num2 % (num1 - 1) == 0){                 cout&lt;&lt;1&lt;&lt;&quot;/&quot;&lt;&lt;num2 / (num1 - 1)&lt;&lt;&quot;+&quot;;                 num1 = 1;             }else{                 int c=num2 / num1 + 1;                 cout &lt;&lt; 1 &lt;&lt; &quot;/&quot; &lt;&lt; c &lt;&lt; &quot;+&quot;;                 num1 = num1 - num2 % num1;                 num2 = num2 * c;                 if (num2 % num1 == 0)                 {                     num2 = num2 / num1;                     num1 = 1;                 }             }         }         cout &lt;&lt; num1 &lt;&lt; &quot;/&quot; &lt;&lt; num2 &lt;&lt; endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>整数数组合并</title>
      <link href="/posts/55180.html"/>
      <url>/posts/55180.html</url>
      
        <content type="html"><![CDATA[<h2 id="整形数组合并"><a href="#整形数组合并" class="headerlink" title="整形数组合并"></a>整形数组合并</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目标题：</p><p>将两个整型数组按照升序合并，并且过滤掉重复数组元素[注: 题目更新了。输出之后有换行]</p><p>详细描述：</p><p>接口说明</p><p>原型：</p><p>voidCombineBySort(int* pArray1,intiArray1Num,int* pArray2,intiArray2Num,int* pOutputArray,int* iOutputNum);</p><p>输入参数：</p><p>int* pArray1 ：整型数组1</p><p>intiArray1Num：数组1元素个数</p><p>int* pArray2 ：整型数组2</p><p>intiArray2Num：数组2元素个数</p><p>输出参数（指针指向的内存区域保证有效）：</p><p>int* pOutputArray：合并后的数组</p><p>int* iOutputNum：合并后数组元素个数</p><p>返回值：</p><p>void</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入说明，按下列顺序输入：1 输入第一个数组的个数2 输入第一个数组的数值3 输入第二个数组的个数4 输入第二个数组的数值</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出合并之后的数组</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>31 2 54-1 0 3 2</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>-101235</code></pre><p>可以用STL标准库中的set集合来做。自动去重。开始还手动给set排序。后来知道原来是已经排好序了。。。</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;int main(){    int num1,num2;    set&lt;int&gt; str;    while(cin&gt;&gt;num1){        int temp = 0;        for(int i = 0;i &lt; num1;i++){            cin&gt;&gt;temp;            str.insert(temp);        }        cin&gt;&gt;num2;        for(int i = 0;i &lt; num2;i++){            cin&gt;&gt;temp;            str.insert(temp);        }        //sort(str.begin(),str.end());        for(auto i=str.begin();i!= str.end();i++){            cout&lt;&lt;*i;        }        cout&lt;&lt;endl;        str.clear();    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>超长正整数相加</title>
      <link href="/posts/11062.html"/>
      <url>/posts/11062.html</url>
      
        <content type="html"><![CDATA[<h2 id="超长正整数相加"><a href="#超长正整数相加" class="headerlink" title="超长正整数相加"></a>超长正整数相加</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请设计一个算法完成两个超长正整数的加法。</p><p>接口说明</p><p> /*<br> 请设计一个算法完成两个超长正整数的加法。<br> 输入参数：<br> String addend：加数<br> String augend：被加数<br> 返回值：加法结果<br> */</p><p> public String AddLongInteger(String addend, String augend)<br> {<br>   /<em>在这里实现功能</em>/</p><p> return null;<br> }</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入两个字符串数字</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出相加后的结果，string型</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>999999999999999999999999999999999999999999999999991</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>100000000000000000000000000000000000000000000000000</code></pre><p>先让两个正整数等长，短的补零。模拟加法运算，从尾部开始，若产生进位就在前一位加1。</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    string str1;    string str2;    while(cin&gt;&gt;str1&gt;&gt;str2){        while(str1.size() &lt; str2.size()){            str1 = &#39;0&#39; + str1;        }        while(str1.size() &gt; str2.size()){            str2 = &#39;0&#39; + str2;        }        int temp = 0,carry = 0;        for(int i = str1.size() - 1;i &gt;= 0;i--){            temp = str1[i] - &#39;0&#39; + str2[i] -&#39;0&#39; + carry;            str1[i] = temp % 10 + &#39;0&#39;;            if(temp / 10){                carry = 1;            }else{                carry = 0;            }        }        if(carry){            str1 = &quot;1&quot; + str1;        }        cout&lt;&lt;str1&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尼科彻斯定理</title>
      <link href="/posts/30413.html"/>
      <url>/posts/30413.html</url>
      
        <content type="html"><![CDATA[<h2 id="尼科彻斯定理"><a href="#尼科彻斯定理" class="headerlink" title="尼科彻斯定理"></a>尼科彻斯定理</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>验证尼科彻斯定理，即：任何一个整数m的立方都可以写成m个连续奇数之和。</p><p>例如：</p><p>1^3=1 </p><p>2^3=3+5 </p><p>3^3=7+9+11 </p><p>4^3=13+15+17+19 </p><p>接口说明</p><p>原型：</p><p> /*<br> 功能: 验证尼科彻斯定理，即：任何一个整数m的立方都可以写成m个连续奇数之和。<br> 原型：<br>   int GetSequeOddNum(int m,char * pcSequeOddNum);<br> 输入参数：<br>   int m：整数(取值范围：1～100)</p><p> 返回值：<br>   m个连续奇数(格式：“7+9+11”);<br> */</p><p> public String GetSequeOddNum(int m)<br> {<br>   /<em>在这里实现功能</em>/</p><p>   return null;<br> }</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入一个int整数</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出分解后的string</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>6</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>31+33+35+37+39+41</code></pre><p>确定首项，再逐个加2输出。</p><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int num;    while(cin&gt;&gt;num){        int star = num*num+1-num;        for(int i = 0;i &lt; num -1;i++){            cout&lt;&lt;star&lt;&lt;&quot;+&quot;;            star += 2;        }        cout&lt;&lt;star&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>公共字串计算</title>
      <link href="/posts/37382.html"/>
      <url>/posts/37382.html</url>
      
        <content type="html"><![CDATA[<h2 id="公共字串计算"><a href="#公共字串计算" class="headerlink" title="公共字串计算"></a>公共字串计算</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目标题：</p><p>计算两个字符串的最大公共字串的长度，字符不区分大小写</p><p>详细描述：</p><p>接口说明</p><p>原型：</p><p>int getCommonStrLength(char * pFirstStr, char * pSecondStr);</p><p>输入参数：</p><p>   char * pFirstStr //第一个字符串</p><p>   char * pSecondStr//第二个字符串</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入两个字符串</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出一个整数</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>asdfas werasdfaswer</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>6</code></pre><p>我参考牛客网<a href="https://www.nowcoder.com/questionTerminal/98dc82c094e043ccb7e0570e5342dd1b?f=discussion" target="_blank" rel="noopener">hofighter</a>的动态规划的做法。(他讲解最长公共子串和最长公共子序列的区别非常好)</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main(){    string str1,str2;    while(cin&gt;&gt;str1&gt;&gt;str2){        int len1 = str1.size();        int len2 = str2.size();        //int dp[][] = new int[len1 + 1][len2 + 1];        vector&lt;vector&lt;int&gt;&gt; dp(len1 + 1 ,vector&lt;int&gt;(len2 + 1,0));        for(int i = 0;i &lt;= len1;i++){            for(int j = 0;j &lt;= len2;j++){                dp[i][j] = 0;            }        }        for(int i = 1;i &lt;= len1;i++){            for(int j = 1;j &lt;= len2;j++){                if(str1[i - 1] == str2[j - 1]){                    dp[i][j] = dp[i - 1][j - 1] + 1;                }else{                    dp[i][j] = 0;                }            }        }        int max = 0;        for(int i = 0;i &lt;= len1;i++){            for(int j = 0;j &lt;= len2;j++){                if(max &lt; dp[i][j]){                    max = dp[i][j];                }            }        }        cout&lt;&lt;max&lt;&lt;endl;    }    return 0;}</code></pre><p>这里附上hofighter的代码。</p><pre class=" language-java"><code class="language-java">链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>nowcoder<span class="token punctuation">.</span>com<span class="token operator">/</span>questionTerminal<span class="token operator">/</span>98dc82c094e043ccb7e0570e5342dd1b<span class="token operator">?</span>f<span class="token operator">=</span>discussion来源：牛客网最长公共子串和最长公共子序列。。。傻傻烦不清楚举个栗子：str1<span class="token operator">=</span><span class="token string">"123ABCD456"</span>  str2 <span class="token operator">=</span> <span class="token string">"ABE12345D"</span>最长公共子串是：<span class="token number">123</span>最长公共子序列是：<span class="token number">12345</span>这两个都可以用动态规划，只是状态转移方程有点区别最长公共子序列是：dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">--</span> 表示子串str1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>i<span class="token punctuation">]</span>和子串str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>j<span class="token punctuation">]</span>的最长公共子序列当str1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> str2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>时，dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>否则，dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>最优解为dp<span class="token punctuation">[</span>len1<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>最长公共子串是： dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">--</span> 表示以str1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>和str2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>为结尾的最长公共子串 当str1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> str2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>时，dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> 否则，dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>最优解为<span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>其中<span class="token number">0</span><span class="token operator">&lt;=</span>i<span class="token operator">&lt;</span>len1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">&lt;=</span>j<span class="token operator">&lt;</span>len2<span class="token punctuation">;</span>so，代码如下： <span class="token comment" spellcheck="true">//求最长公共子串</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Scanner<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        Scanner sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        String str1 <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        String str2 <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            str1 <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            str2 <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getCommonStrLength</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getCommonStrLength</span><span class="token punctuation">(</span>String str1<span class="token punctuation">,</span> String str2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> len1 <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> str2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> str2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//区别在这儿        </span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>max <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                    max <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//求最长公共子序列 import java.util.Scanner;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        Scanner sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        String str1 <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        String str2 <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            str1 <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            str2 <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getCommonStrLength</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getCommonStrLength</span><span class="token punctuation">(</span>String str1<span class="token punctuation">,</span> String str2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> len1 <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> str2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> str2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//区别在这儿        </span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参数解析</title>
      <link href="/posts/46242.html"/>
      <url>/posts/46242.html</url>
      
        <content type="html"><![CDATA[<h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在命令行输入如下命令：</p><p>xcopy /s c:\ d:\，</p><p>各个参数如下： </p><p>参数1：命令字xcopy </p><p>参数2：字符串/s</p><p>参数3：字符串c:\</p><p>参数4: 字符串d:\</p><p>请编写一个参数解析程序，实现将命令行各个参数解析出来。</p><p>解析规则： </p><p>1.参数分隔符为空格<br>2.对于用“”包含起来的参数，如果中间有空格，不能解析为多个参数。比如在命令行输入xcopy /s “C:\program files” “d:\”时，参数仍然是4个，第3个参数应该是字符串C:\program files，而不是C:\program，注意输出参数时，需要将“”去掉，引号不存在嵌套情况。<br>3.参数不定长<br>4.输入由用例保证，不会出现不符合要求的输入 </p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code>输入一行字符串，可以有空格</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>输出参数个数，分解后的参数，每个参数都独占一行</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>xcopy /s c:\\ d:\\</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>4xcopy/sc:\\d:\\</code></pre><p>我的做法是先把“”引号去掉，在把参数逐个放进容器中，然后遍历出来即可。参数的个数 = 空格数 + 1。</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main(){    string str;    while(getline(cin,str)){        vector&lt;string&gt; str1;        string temp;        string temp2;        int isnull = 1;        //将“”引号去掉，同时计算空格的数目，空格数加1等于参数个数        for(int i = 0;i &lt; str.size();i++){            if(str[i] != &#39;&quot;&#39;){                temp += str[i];            }            if(str[i] == &#39; &#39;){                isnull++;            }        }        //将参数放入容器中        for(int i = 0;i &lt; temp.size();i++){            if(temp[i] != &#39; &#39;){                temp2 += temp[i];            }else{                str1.push_back(temp2);                temp2 = &quot;&quot;;            }        }        //不要忘记把最后一个参数放进容器，因为该参数后面是没有空格的。        str1.push_back(temp2);        cout&lt;&lt;isnull&lt;&lt;endl;        for(int i = 0;i &lt; str1.size();i++){            cout&lt;&lt;str1[i]&lt;&lt;endl;        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Picker、FloatingActionButton和AlertDialog的使用</title>
      <link href="/posts/55156.html"/>
      <url>/posts/55156.html</url>
      
        <content type="html"><![CDATA[<h2 id="Picker、FloatingActionButton和AlertDialog的使用"><a href="#Picker、FloatingActionButton和AlertDialog的使用" class="headerlink" title="Picker、FloatingActionButton和AlertDialog的使用"></a>Picker、FloatingActionButton和AlertDialog的使用</h2><p>直接上XML代码，用了一个时间选择器，一个悬浮操作按钮和普通按钮。</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.constraintlayout.widget.ConstraintLayout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>app</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res-auto<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>tools</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/tools<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">tools:</span>context</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.MainActivity<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    //时间选择器    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TimePicker</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/timepiker<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintStart_toStartOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintTop_toTopOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TimePicker</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/textView<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Hello World!<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintBottom_toBottomOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintLeft_toLeftOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintRight_toRightOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintTop_toTopOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com.google.android.material.floatingactionbutton.FloatingActionButton</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/floatingActionButton2<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginEnd</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>183dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginRight</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>183dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginBottom</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>153dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>clickable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintBottom_toBottomOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintEnd_toEndOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">tools:</span>srcCompat</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@tools:sample/backgrounds/scenic<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    //简单对话框    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/button<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginStart</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>44dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginLeft</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>44dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginEnd</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>41dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginRight</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>41dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginBottom</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>简单对话框<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintBottom_toTopOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/floatingActionButton2<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintEnd_toStartOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/floatingActionButton2<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintStart_toStartOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.constraintlayout.widget.ConstraintLayout</span><span class="token punctuation">></span></span></code></pre><p>接下来是Java代码，实现一些简单的提示信息。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>gdlgxy<span class="token punctuation">.</span>othercomponents<span class="token punctuation">;</span><span class="token keyword">import</span> androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AlertDialog<span class="token punctuation">;</span><span class="token keyword">import</span> androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AppCompatActivity<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>DialogInterface<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Bundle<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>Button<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>TimePicker<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>Toast<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>android<span class="token punctuation">.</span>material<span class="token punctuation">.</span>floatingactionbutton<span class="token punctuation">.</span>FloatingActionButton<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>android<span class="token punctuation">.</span>material<span class="token punctuation">.</span>snackbar<span class="token punctuation">.</span>Snackbar<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//时间选择器</span>        TimePicker timePicker <span class="token operator">=</span> <span class="token punctuation">(</span>TimePicker<span class="token punctuation">)</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>timepiker<span class="token punctuation">)</span><span class="token punctuation">;</span>        timePicker<span class="token punctuation">.</span><span class="token function">setOnTimeChangedListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimePicker<span class="token punctuation">.</span>OnTimeChangedListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onTimeChanged</span><span class="token punctuation">(</span>TimePicker view<span class="token punctuation">,</span> <span class="token keyword">int</span> hourOfDay<span class="token punctuation">,</span> <span class="token keyword">int</span> minute<span class="token punctuation">)</span> <span class="token punctuation">{</span>                String str <span class="token operator">=</span> hourOfDay <span class="token operator">+</span> <span class="token string">"时"</span> <span class="token operator">+</span> minute <span class="token operator">+</span> <span class="token string">"分"</span><span class="token punctuation">;</span>                Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//悬浮按钮</span>        FloatingActionButton floatingActionButton <span class="token operator">=</span> <span class="token punctuation">(</span>FloatingActionButton<span class="token punctuation">)</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>floatingActionButton2<span class="token punctuation">)</span><span class="token punctuation">;</span>        floatingActionButton<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">View<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Snackbar<span class="token punctuation">.</span><span class="token function">make</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token string">"这是个悬浮按钮"</span><span class="token punctuation">,</span> Snackbar<span class="token punctuation">.</span>LENGTH_LONG<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAction</span><span class="token punctuation">(</span><span class="token string">"Action"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//简单对话框</span>        Button dialog_btn <span class="token operator">=</span> <span class="token punctuation">(</span>Button<span class="token punctuation">)</span><span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>button<span class="token punctuation">)</span><span class="token punctuation">;</span>        dialog_btn<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">View<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                AlertDialog<span class="token punctuation">.</span>Builder mBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlertDialog<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                mBuilder<span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token string">"这是一个对话框！"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPositiveButton</span><span class="token punctuation">(</span><span class="token string">"确定"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">"您点击了确定！"</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setNegativeButton</span><span class="token punctuation">(</span><span class="token string">"取消"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">"您点击了取消！"</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"提示对话框"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 安卓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown学习</title>
      <link href="/posts/54885.html"/>
      <url>/posts/54885.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习</h1><h2 id="第一节-Markdown介绍"><a href="#第一节-Markdown介绍" class="headerlink" title="第一节  Markdown介绍"></a>第一节  Markdown介绍</h2><h3 id="Markdown介绍"><a href="#Markdown介绍" class="headerlink" title="Markdown介绍"></a>Markdown介绍</h3><p>Markdown是一种轻量级标记语言，知道他可以写文本就完事了。</p><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>个人用Typora编辑器，不过不用编辑器也可以，Markdown可以纯文本编写文档，文件后缀是.md或者.markdown。</p><p>Typora官网：<a href="https://typora.io/" target="_blank" rel="noopener">Typora</a></p><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><p>《了不起的Markdown》</p><h3 id="用Typora开始Markdown之旅"><a href="#用Typora开始Markdown之旅" class="headerlink" title="用Typora开始Markdown之旅"></a>用Typora开始Markdown之旅</h3><pre class=" language-markdown"><code class="language-markdown"><span class="token title important"><span class="token punctuation">#</span> hello world</span></code></pre><p>复制这句代码到Typora上（注意#号后有空格），显示效果如下：</p><p><img src="https://s1.ax1x.com/2020/04/15/JikvPe.png" alt="helloworld"></p><h2 id="第二节-标题"><a href="#第二节-标题" class="headerlink" title="第二节  标题"></a>第二节  标题</h2><p>使用#号表示1~6级标题，一级标题对应一个#号，以此类推</p><pre class=" language-markdown"><code class="language-markdown"><span class="token title important"><span class="token punctuation">#</span> 是一级标题呀</span><span class="token title important"><span class="token punctuation">##</span> 是二级标题呀</span><span class="token title important"><span class="token punctuation">###</span> 是三级标题呀</span><span class="token title important"><span class="token punctuation">####</span> 是四级标题呀</span><span class="token title important"><span class="token punctuation">#####</span> 是五级标题呀</span><span class="token title important"><span class="token punctuation">######</span> 是六级标题呀</span></code></pre><p>效果如下图：</p><p><img src="https://s1.ax1x.com/2020/04/15/JiAdqx.png" alt="标题"></p><h2 id="第三节-段落"><a href="#第三节-段落" class="headerlink" title="第三节  段落"></a>第三节  段落</h2><p>Markdown的段落没啥特殊格式，直接Ctrl + 0就好了。</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown有多种字体，喜欢或者需要哪种可自行选择</p><pre class=" language-markdown"><code class="language-markdown"><span class="token italic"><span class="token punctuation">*</span>斜体文本<span class="token punctuation">*</span></span><span class="token italic"><span class="token punctuation">_</span>斜体文本<span class="token punctuation">_</span></span><span class="token bold"><span class="token punctuation">**</span>粗体文本<span class="token punctuation">**</span></span><span class="token bold"><span class="token punctuation">__</span>粗体文本<span class="token punctuation">__</span></span><span class="token bold"><span class="token punctuation">**</span>*粗斜体文本<span class="token punctuation">**</span></span>*<span class="token bold"><span class="token punctuation">__</span>_粗斜体文本<span class="token punctuation">__</span></span>_</code></pre><p>在Typora中的效果如图：</p><p><img src="https://s1.ax1x.com/2020/04/15/JimaEq.png" alt="字体"></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落中需要用到删除线，可以在段落两边添加两个  ~~  波浪线来实现。</p><pre class=" language-markdown"><code class="language-markdown">~~删除线~~</code></pre><p>效果如图：</p><p><img src="https://s1.ax1x.com/2020/04/15/Jin4wn.png" alt="删除线"></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注可以对文本进行补充说明</p><pre class=" language-markdown"><code class="language-markdown">//格式如下[^需要说明的文本]//示例代码Markdown学习[^Markdown][^Markdown]:Markdown是一种轻量级标记语言</code></pre><p>效果如下：</p><p><img src="https://s1.ax1x.com/2020/04/15/JiMGiq.png" alt="脚注"></p><h2 id="第四节-列表"><a href="#第四节-列表" class="headerlink" title="第四节  列表"></a>第四节  列表</h2><h3 id="有序列表和无序列表"><a href="#有序列表和无序列表" class="headerlink" title="有序列表和无序列表"></a>有序列表和无序列表</h3><p>无序列表使用星号(<strong>***)、加号(</strong>+<strong>)或是减号(</strong>-**)作为列表标记</p><p>有序列表使用 . 号</p><pre class=" language-markdown"><code class="language-markdown">//无序列表<span class="token list punctuation">*</span> 迪迦<span class="token list punctuation">+</span> 戴拿<span class="token list punctuation">-</span> 盖亚//有序列表<span class="token list punctuation">1.</span> 迪迦<span class="token list punctuation">2.</span> 戴拿<span class="token list punctuation">3.</span> 盖亚</code></pre><p>效果如下：</p><p><img src="https://s1.ax1x.com/2020/04/15/Ji8MUH.png" alt="列表"></p><h3 id="列表进阶之嵌套列表"><a href="#列表进阶之嵌套列表" class="headerlink" title="列表进阶之嵌套列表"></a>列表进阶之嵌套列表</h3><p>子列表在选项前面加四个空格就可以了</p><pre class=" language-markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> 平成系奥特曼<span class="token code keyword">    * 迪迦</span><span class="token code keyword">    + 戴拿</span><span class="token code keyword">    - 盖亚</span></code></pre><p>效果如下：</p><p><img src="https://s1.ax1x.com/2020/04/15/Ji8LZD.png" alt="嵌套列表"></p><h2 id="第五节-区块与代码区块"><a href="#第五节-区块与代码区块" class="headerlink" title="第五节  区块与代码区块"></a>第五节  区块与代码区块</h2><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个空格符号：</p><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> 少年乙的博客<span class="token blockquote punctuation">></span> 其他小伙伴的博客</code></pre><p>效果如下：</p><p><img src="https://s1.ax1x.com/2020/04/15/JiJ8nf.png" alt="区块"></p><h3 id="区块进阶之嵌套区块"><a href="#区块进阶之嵌套区块" class="headerlink" title="区块进阶之嵌套区块"></a>区块进阶之嵌套区块</h3><p>一个 <strong>&gt;</strong> 符号是最外层，两个 <strong>&gt;</strong> 符号是第一层嵌套，以此类推：</p><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> 少年乙的博客<span class="token blockquote punctuation">> ></span> 阅读文章<span class="token blockquote punctuation">> > ></span> 阅读完毕</code></pre><p>效果如下：</p><p><img src="https://s1.ax1x.com/2020/04/15/JiYRZ8.png" alt="嵌套区块"></p><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>用```开始代码区块，需要的话可以选定一种语言,选定了的话代码区块里的代码会高亮显示</p><pre class=" language-markdown"><code class="language-markdown">​```for(int i = 0; i &lt; str.size();i++){<span class="token code keyword">    cout&lt;&lt;"***"&lt;&lt;endl;</span>}</code></pre><p>效果如下：</p><p><img src="https://s1.ax1x.com/2020/04/15/JiDtsJ.png" alt="代码区块"></p><h2 id="第六节-链接与图片"><a href="#第六节-链接与图片" class="headerlink" title="第六节  链接与图片"></a>第六节  链接与图片</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><pre class=" language-markdown"><code class="language-markdown">//链接的两种格式<span class="token url">[链接名](链接地址)</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>链接地址</span><span class="token punctuation">></span></span>//例子少年乙的博客<span class="token url">[传送门](https://1224756742.github.io/)</span></code></pre><p>效果如下：</p><p><img src="https://s1.ax1x.com/2020/04/15/Jisw8K.png" alt="链接"></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>嘻嘻，我的每个  效果如下  的测试图片都是用下面的方式写的</p><pre class=" language-markdown"><code class="language-markdown">//图片的格式<span class="token url">![属性文本](图片地址)</span><span class="token url">![我的头像](https://1224756742.github.io/medias/avatar.jpg)</span></code></pre><p>效果如下：</p><p><img src="https://s1.ax1x.com/2020/04/15/JiyaZj.png" alt="图片"></p><h2 id="第七节-表格"><a href="#第七节-表格" class="headerlink" title="第七节  表格"></a>第七节  表格</h2><p>使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行</p><pre class=" language-markdown"><code class="language-markdown">|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 |</code></pre><p>效果如下：</p><p><img src="https://s1.ax1x.com/2020/04/15/Ji69l8.png" alt="表格"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习了Marndown的基本语法，编写一般的文档ok啦！！！</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算日期到天数转换</title>
      <link href="/posts/5532.html"/>
      <url>/posts/5532.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算日期到天数转换"><a href="#计算日期到天数转换" class="headerlink" title="计算日期到天数转换"></a>计算日期到天数转换</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>根据输入的日期，计算是这一年的第几天。。</p><p>详细描述：</p><p>输入某年某月某日，判断这一天是这一年的第几天？。</p><p>接口设计及说明：</p><p> /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br> Description  : 数据转换<br> Input Param  : year 输入年份<br>        Month 输入月份<br>        Day 输入天</p><p> Output Param :<br> Return Value : 成功返回0，失败返回-1（如：数据错误）<br> <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br> public static int iConverDateToDay(int year, int month, int day)<br> {<br>   /* 在这里实现功能，将结果填入输入数组中*/<br>   return 0;<br> }</p><p> /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br> Description  :<br> Input Param  :</p><p> Output Param :<br> Return Value : 成功:返回outDay输出计算后的第几天;<br>                      失败:返回-1<br> <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br> public static int getOutDay()<br> {<br> return 0;<br> }</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入三行，分别是年，月，日</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>成功:返回outDay输出计算后的第几天;失败:返回-1</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>20121231</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>366</code></pre><p>这题有个隐藏条件，需要判断输入年份是闰年还是平年。如果能被4整除但不能被100整除的是闰年，还有能被400整除的也是闰年。</p><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int year, month,day;    while(cin&gt;&gt;year&gt;&gt;month&gt;&gt;day){        int count = 0;        const int res[] = {0,31,59,90,120,151,181,212,243,273,304,334,365};        if(month &lt;= 0 || month &gt; 12 || day &lt;= 0 || day &gt; 31){            return -1;        }        else{            count = res[month - 1] + day;            if((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0){                count++;            }        }        cout&lt;&lt;count&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>百钱买百鸡问题</title>
      <link href="/posts/2755.html"/>
      <url>/posts/2755.html</url>
      
        <content type="html"><![CDATA[<h2 id="百钱买百鸡问题"><a href="#百钱买百鸡问题" class="headerlink" title="百钱买百鸡问题"></a>百钱买百鸡问题</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>公元前五世纪，我国古代数学家张丘建在《算经》一书中提出了“百鸡问题”：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？</p><p>详细描述：</p><p>接口说明</p><p>原型：</p><p>int GetResult(vector &amp;list)</p><p>输入参数：</p><p>​    无</p><p>输出参数（指针指向的内存区域保证有效）：</p><p>  list 鸡翁、鸡母、鸡雏组合的列表</p><p>返回值：</p><p>   -1 失败   </p><p>   0 成功</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入任何一个整数，即可运行程序。</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code></code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>1</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>0 25 754 18 788 11 8112 4 84</code></pre><p>根据题目描述，可以的到五条关系式<br>$$<br>鸡翁+鸡母+鸡雏 = 100<br>5<em>鸡翁+3</em>鸡母+3/鸡雏 = 100<br>0 &lt; 鸡翁 &lt; 100<br>0 &lt; 鸡母 &lt; 100<br>0 &lt; 鸡雏 &lt; 100<br>$$<br>暴力点，计算机可以ok。</p><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int num;    while(cin&gt;&gt;num){        int x,y,z;        for(int x = 0;x &lt;= 100;x++){            for(int y = 0;y &lt;= 100;y++){                for(int z = 0;z &lt;= 100;z++){                    if(x + y + z == 100 &amp;&amp; z % 3 == 0 &amp;&amp; 5*x + 3 * y + z / 3 == 100){                        cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;endl;                    }                }            }        }    }    return 0;}</code></pre><p>用了三个for循环，时间复杂度是O(n*n*n)，这样的复杂度可以通过华为的测试，不过还是可以优化一下的。上面的关系式可以化简得到<br>$$<br>7<em>x + 4</em>y = 100<br>0 &lt;= 鸡翁 &lt;= 14<br>0 &lt;= 鸡母 &lt;= 25<br>$$<br>根据公式写代码</p><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int num;    while(cin&gt;&gt;num){        int x,y,z;        for(int x = 0;x &lt;= 14;x++){            for(int y = 0;y &lt;= 25;y++){                 if(7 * x + 4 * y == 100 ){                     z = 100 - x - y;                    cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;endl;                 }             }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串通配符</title>
      <link href="/posts/57570.html"/>
      <url>/posts/57570.html</url>
      
        <content type="html"><![CDATA[<h2 id="字符串通配符"><a href="#字符串通配符" class="headerlink" title="字符串通配符"></a>字符串通配符</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>问题描述：在计算机中，通配符一种特殊语法，广泛应用于文件搜索、数据库、正则表达式等领域。现要求各位实现字符串通配符的算法。<br>要求：<br>实现如下2个通配符：<br>*：匹配0个或以上的字符（字符由英文字母和数字0-9组成，不区分大小写。下同）<br>？：匹配1个字符</p><p>输入：<br>通配符表达式；<br>一组字符串。</p><p>输出：<br>返回匹配的结果，正确输出true，错误输出false</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>先输入一个带有通配符的字符串，再输入一个需要匹配的字符串</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>返回匹配的结果，正确输出true，错误输出false</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>te?t*.*txt12.xls</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>false</code></pre><p>按题目意思写</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;nt main(){    string str1;    string str2;    while(cin&gt;&gt;str1&gt;&gt;str2){        int i = 0,j = 0;        bool flag = false;        while(str2[i] != &#39;\0&#39; || str1[j] != &#39;\0&#39;){            if(str1[j] == &#39;*&#39;){                j++;                flag = true;            }            else if(str2[i] == str1[j] || str1[j] == &#39;?&#39;){                i++;                j++;            }            else if(flag == true){                while(str2[i] != str1[j]){                    i++;                }                flag = false;            }            else{                cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;                break;            }        }        if(str2[i] == &#39;\0&#39; &amp;&amp; str2[j] == &#39;\0&#39;){                cout&lt;&lt;&quot;true&quot;&lt;&lt;endl;            }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 通配符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵乘法</title>
      <link href="/posts/60626.html"/>
      <url>/posts/60626.html</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如果A是个x行y列的矩阵，B是个y行z列的矩阵，把A和B相乘，其结果将是另一个x行z列的矩阵C。这个矩阵的每个元素是由下面的公式决定的</p><p><img src="https://uploadfiles.nowcoder.com/images/20190910/59_1568118638276_0FD75AC03CF8B932814B63C207D854C2" alt="img"></p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入包含多组数据，每组数据包含：第一行包含一个正整数x，代表第一个矩阵的行数第二行包含一个正整数y，代表第一个矩阵的列数和第二个矩阵的行数第三行包含一个正整数z，代表第二个矩阵的列数之后x行，每行y个整数，代表第一个矩阵的值之后y行，每行z个整数，代表第二个矩阵的值</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>对于每组输入数据，输出x行，每行z个整数，代表两个矩阵相乘的结果</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>2321 2 33 2 11 22 13 3</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>14 1310 11</code></pre><p>这道题需要知晓矩阵乘法是怎么算的，运算过程如下</p><p><img src="data:image/jpeg;base64,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" alt="矩阵乘法"></p><p>既然知晓了矩阵乘法怎么算，这道题就可以直接写了。</p><pre><code>#incude&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(){    int x,y,z;    while(cin&gt;&gt;x&gt;&gt;y&gt;&gt;z){        vector&lt;vector&lt;int&gt;&gt; first(x, vector&lt;int&gt;(y, 0));        vector&lt;vector&lt;int&gt;&gt; second(y, vector&lt;int&gt;(z, 0));        vector&lt;vector&lt;int&gt;&gt; result(x, vector&lt;int&gt;(z, 0));        for(int i = 0;i &lt; x;i++){            for(int j = 0;j &lt; y;j++){                cin&gt;&gt;first[i][j];            }        }        for(int i = 0;i &lt; y;i++){            for(int j = 0;j &lt; z;j++){                cin&gt;&gt;second[i][j];            }        }        for(int i = 0;i &lt; x;i++){            for(int j = 0;j &lt; y;j++){                for(int k = 0;k &lt; z;k++){                    result[i][k] += first[i][j] * second[j][k];                }            }        }        for(int i = 0;i &lt; x;i++){            for(int j = 0;j &lt; z - 1;j++){                cout&lt;&lt;result[i][j]&lt;&lt;&quot; &quot;;    //题目的输出有格式要求，每行的最后一个需要换行            }            cout&lt;&lt;result[i][z - 1]&lt;&lt;endl;        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成绩排序</title>
      <link href="/posts/33506.html"/>
      <url>/posts/33506.html</url>
      
        <content type="html"><![CDATA[<h2 id="成绩排序"><a href="#成绩排序" class="headerlink" title="成绩排序"></a>成绩排序</h2><p>查找和排序</p><p>题目：输入任意（用户，成绩）序列，可以获得成绩从高到低或从低到高的排列,相同成绩<br>都按先录入排列在前的规则处理。</p><p>例示：<br>jack   70<br>peter   96<br>Tom    70<br>smith   67</p><p>从高到低 成绩<br>peter   96<br>jack   70<br>Tom    70<br>smith   67</p><p>从低到高</p><p>smith   67</p><p>Tom    70<br>jack   70</p><p>peter   96</p><p>注：0代表从高到低，1代表从低到高</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><pre><code>输入多行，先输入要排序的人的个数，然后分别输入他们的名字和成绩，以一个空格隔开</code></pre><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><pre><code>按照指定方式输出名字和成绩，名字和成绩之间以一个空格隔开</code></pre><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>30fang 90yang 50ning 70</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>fang 90ning 70yang 50</code></pre><p>用桶排序的思路，因为分数在0~100分之间，一个分数桶对应一个学生，哈哈，键值对的感觉有木有。下面是代码 </p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main(){    int number,hd;    string name;    int grade;    while(cin&gt;&gt;number&gt;&gt;hd){        string strarr[101];        int nums[101] = {0};        for(int i = 0;i &lt; number;i++){            cin&gt;&gt;name&gt;&gt;grade;            strarr[grade] = name;            nums[grade] = 1;        }        if(hd == 0){            for(int i = 100;i &gt;= 0;i--){                if(nums[i] != 0){                    cout&lt;&lt;strarr[i]&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;                }            }        }        else{            for(int i = 0;i &lt; 101;i++){                if(nums[i] != 0){                    cout&lt;&lt;strarr[i]&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;                }            }        }    }    return 0;}</code></pre><p>不过这种放在一维数组的做法是不足以解决这道题的，因为当出现两个用户的分数是一样的时候，所以这个程序的鲁棒性是不够给力的。<br>去牛客网得到讨论区，发现用容器可以解决多个用户分数一样的问题，附一下链接和代码。</p><pre><code>//来源：牛客网//链接：https://www.nowcoder.com/questionTerminal/8e400fd9905747e4acc2aeed7240978b?f=discussion#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main(){    int n;    int way;    string name;    int grade;    while(cin &gt;&gt; n &gt;&gt; way)    {        vector&lt;string&gt; b[101];  //0-100分的桶共101个        for(int i = 0; i &lt; n; i++)        {            cin &gt;&gt; name &gt;&gt; grade;            b[grade].push_back(name);        }        if(way == 0)        {          for(int i = 100 ; i &gt;= 0; i--)          {             for(int j = 0; j &lt; b[i].size(); j++)                 cout &lt;&lt; b[i][j] &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;          }        }        else        {          for(int i = 0 ; i &lt; 101; i++)          {             for(int j = 0; j &lt; b[i].size(); j++)                 cout &lt;&lt; b[i][j] &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;          }        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
